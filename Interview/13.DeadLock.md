# 13 단원 교착 상태

데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.

- 정답
    
    데드락 ? 
    
    **둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황**을 말합니다.
    
    - 상호 배제
        - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제 될 때까지 기다려야 한다.
    - 점유 대기
        - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
    - 비선점
        - 이미 할당된 자원을 강제로 빼앗을 수 없다.
    - 순환 대기
        - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.

- 정답
    
    안전 상태를 유지하도록 자원을 할당하는 방식입니다. 
    
    - 자원 할당 허용 여부를 결정하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부를 검사한다. 그런 다음 대기 중인 다른 모든 활동의 교착 상태 가능성을 조사하여 “안전 상태” 여부를 검사 확인한다.

기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.

- 정답
    
    교착 상태 해결책
    
    1. n명이 앉을 수 있는 테이블에서 철학자를 n-1명만 앉힘
    2. 한 철학자가 젓가락 두개를 모두 집을 수 있는 상황에서만 젓가락 집도록 허용
    3. 누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용

교착 상태를 예방할 수 있는 방법을 설명해 보세요.

- 정답
    
    교착 상태를 예방하기 위해서 교착 상태가 일어나는 4가지 원칙 중 1가지를 제거 합니다
    
    4가지 원칙 : 상호배제, 점유와 대기, 비선점, 원형 대기
    
    - 꼬리 질문 : OOOO원칙을 제거하는 방법과 부작용(단점)에 대해 설명
        
        **상호 배제 제거** : 모든 자원을 공유 가능하게 만든다
        
        부작용 : 비현실적이다
        
        **점유 대기 제거** : 프로세스에게 필요한 모든 자원을 할당 가능할 때만 할당한다. 모두 혹은 아예 할당하지 않는다.
        
        부작용 : 자원의 활용률이 낮아진다, 자원을 많이 필요로하는 자원이 불리해진다(기아 현상 발생)
        
        **비선점 제거** : 자원을 이용 중인 프로세스로부터 자원을 강제로 빼앗는다. CPU와 같이 선점하여 사용할 수 있는 일부 자원에 대해서는 효과적이다
        
        부작용 : 모든 자원이 선점 가능 하지 않다. 따라서 범용성이 떨어진다
        
        **원형 대기 제거** : 모든 자원에 번호를 붙이고, 오름 차순으로 자원을 할당한다
        
        부작용 : 단점 : 자원이 많아서 현실적으로 어렵고, 어떻게 번호를 붙이는지에 따라 자원 활용률이 감소한다
        

Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

- 정답
    
    4가지 원칙 : 상호배제, 점유와 대기, 비선점, 원형 대기
    

그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

- 정답
    - 상호 배제
        - **충족되지 않으면**: 자원이 공유 가능하면, 여러 프로세스가 동시에 자원을 사용할 수 있으므로 교착 상태가 발생하지 않습니다.
    - 점유와 대기
        - **충족되지 않으면**: 프로세스가 자원을 점유하고 있을 때 다른 자원을 기다리지 않으면, 교착 상태가 발생하지 않습니다. 예를 들어, 모든 자원을 한 번에 요청하거나, 자원을 점유하지 않은 상태에서만 자원을 요청하면 됩니다.
    - 비선점
        - **충족되지 않으면**: 한 프로세스가 다른 프로세스의 자원을 강제로 회수할 수 있으면, 자원을 계속해서 사용할 수 있으므로 교착 상태가 발생하지 않습니다.
    - 원형 대기
        - **충족되지 않으면**: 자원을 기다리는 프로세스 간에 원형 대기가 형성되지 않도록 하면, 교착 상태가 발생하지 않습니다. 예를 들어, 자원에 순서를 부여하고 프로세스가 항상 순서대로 자원을 요청하게 하면, 원형 대기가 발생하지 않습니다.

어떤 방식으로 예방할 수 있을까요?

왜 현대 OS는 Deadlock을 처리하지 않을까요?

- 정답
    
    DeadLock은 거의 발생하지 않고 예방, 회피 방식은 비용이 너무 큼
    
    감지하고 해결하는 메커니즘을 운영체제에 포함시키면 시스템의 복잡성이 크게 증가
    
    발생한 후 이를 회복하는 전략은 일반적으로 비효율적입니다. 예를 들어, 프로세스를 강제 종료하거나 자원을 강제로 회수하는 방법은 애플리케이션 상태를 불안정하게 만들고, 데이터 손실이나 시스템 오류를 초래할 수 있음
    
    결론적으로 현대 OS는 데드락의 처리가 비효율적이기 때문에 무시하는 방식을 취하며 책임을 지지 않는다
    

Wait Free와 Lock Free를 비교해 주세요.

데드락이 일어났는지 탐지하는 기법은?

- 정답
    - **탐지 기법**
        - Allocation, Request, Available 등으로 시스템에 **데드락이 발생했는지 여부를 탐색**합니다. 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악합니다.
        - 이 외에도 **자원 할당 그래프를 통해 탐지**하는 방법도 있습니다.

**탐지 기법 중 Allocation**, **Request**, 그리고 **Available 에 대해 설명해주세요?**

- 정답
    - **Allocation (할당 행렬)**:
        - 각 프로세스가 현재 가지고 있는 자원의 수를 나타내는 행렬입니다.
        - 행렬의 각 원소 A[i][j]는 프로세스 Pi가 자원 Rj를 얼마나 가지고 있는지를 의미합니다.
            
            A[i][j]A[i][j]
            
            PiP_i
            
            RjR_j
            
    - **Request (요청 행렬)**:
        - 각 프로세스가 요청한 자원의 수를 나타내는 행렬입니다.
        - 행렬의 각 원소 Q[i][j]는 프로세스 Pi가 자원 Rj를 얼마나 더 필요로 하는지를 의미합니다.
            
            Q[i][j]Q[i][j]
            
            PiP_i
            
            RjR_j
            
    - **Available (가용 벡터)**:
        - 현재 시스템에서 사용할 수 있는 각 자원의 수를 나타내는 벡터입니다.
        - 벡터의 각 원소 V[j]는 자원 Rj가 시스템에서 얼마나 가용한지를 의미합니다.
            
            V[j]V[j]
            
            RjR_j
            

**회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.**

- 정답
    
    은행원 알고리즘은 은행에서 현금을 할당하는 것에서 유래한 알고리즘입니다.
    프로세스가 자원을 요구할때 자원을 할당한 후에도 안정 상태이면 자원을 할당하고, 그렇지 않으면 다른 자원이 해제될때까지 대기했다가 자원을 할당합니다.
    

**은행원 알고리즘의 단점**

- 정답
    
    할당할 수 있는 자원수가 일정 해야한다.
    
    항상 불안전 상태를 방지해야 하므로 **자원 이용도가 낮다**
    
    **최대 자원 요구량**을 미리 알아야 한다.
    
    프로세스들은 유한한 시간 안에 자원을 반납해야 한다.
    

[**'식사하는 철학자 문제'에서, DeadLock이 어떨 때 발생하는지 설명하고, 이를 해결하기 위한 방법을 제시해주세요.**](https://hoons-dev.tistory.com/95?category=1091955#%F-%-F%--%A-%---%EC%-B%-D%EC%--%AC%ED%--%--%EB%-A%--%--%EC%B-%A-%ED%--%--%EC%-E%--%--%EB%AC%B-%EC%A-%-C-%EC%--%--%EC%--%-C%-C%--DeadLock%EC%-D%B-%--%EC%--%B-%EB%--%A-%--%EB%--%-C%--%EB%B-%-C%EC%--%-D%ED%--%--%EB%-A%--%EC%A-%--%--%EC%--%A-%EB%AA%--%ED%--%--%EA%B-%A-%-C%--%EC%-D%B-%EB%A-%BC%--%ED%--%B-%EA%B-%B-%ED%--%--%EA%B-%B-%--%EC%-C%--%ED%--%-C%--%EB%B-%A-%EB%B-%--%EC%-D%--%--%EC%A-%-C%EC%-B%-C%ED%--%B-%EC%A-%BC%EC%--%B-%EC%-A%---)

- 정답
    
    모든 철학자가 방에 입장한 후, 각자의 왼쪽포크를 5명이 모두 드는 경우에 DeadLock이 발생합니다.
    
    1) 5명 모두 자신의 왼쪽 포크를 들고 있으므로 '점유대기'
    
    2) 남이 포크를 뺏어주지 않음 '비선점'
    
    3) 서로 오른쪽 포크를 놓기만을 기다림 '환형대기'
    
    4) 각 포크에 대해 한 사람만 들 수 있음 '상호배제'
    
    이 문제를 해결하기 위해서, 카운팅 세마포어를 사용합니다.
    
    방에 대한 입장 정원을 카운팅 세마포어로 설계해, 최대 4명만 들어온다면 방 안의 모든 사람들이 왼쪽 포크를 든다 하더라도 DeadLock이 일어나지 않습니다.
    

[**희생자 선택은 어떻게 결정합니까?**](https://deious.tistory.com/298#%F0%9F%92%A1%20%ED%9D%AC%EC%83%9D%EC%9E%90%20%EC%84%A0%ED%83%9D%EC%9D%80%20%EC%96%B4%EB%96%BB%EA%B2%8C%20%EA%B2%B0%EC%A0%95%ED%95%A9%EB%8B%88%EA%B9%8C%3F-1)

- 정답
    
    프로세스 종료의 비용을 최소화하기 위하여 비용을 계산합니다.
    
    비용 요인으로는 교착상태 프로세스가 점유하고 있는 자원의 수, 프로세스가 지금까지 실행하는 데 소요한 시간들과 같은 매개변수들들 고려하여 결정합니다.
    

Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.

- 정답
    
    두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산결과의 정합성이 보장될 수 있게끔 메모리 가시성이 확보된 상태를 의미합니다.
    
    - java.util.concurrent 패키지 하위의 클래스를 사용합니다.
    - 인스턴스 변수를 두지 않습니다.
    - Singleton 패턴을 사용합니다.(이 때, 일반적으로 구현하는 Singleton Pattern은 Thread-safe 하지 않습니다.)[참고](https://github.com/ksundong/TIL/blob/master/DesignPattern/singleton-pattern.md)
    - 동기화(syncronized) 블럭에서 연산을 수행합니다.
- 꼬리질문
    - Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?
    - Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.
    - Race Condition 이 무엇인가요?
    - Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?

교착상태와 기아상태의 해결방법에 대해 설명해보세요.

- 정답
    
    교착상태(Deadlock)가 무엇인지 알고 있어야 합니다. 서로 다른 프로세스가 서로 점유하고 있는 자원의 반납을 대기하고 있는 상태를 의미합니다.
    
    발생조건
    
    - 상호 배제: 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 합니다.
    - 점유 대기: 할당된 자원을 가진 상태에서 다른 자원을 기다립니다.
    - 비선점: 다른 프로세스가 자원의 사용을 끝낼 때 까지 자원을 뺏을 수 없습니다.
    - 순환대기: 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있습니다.
    
    해결방법
    
    - 예방: 4가지 조건 중 하나라도 만족되지 않도록 합니다.
    - 회피: 알고리즘을 데드락이 발생하지 않도록 합니다.
    - 회복: 교착상태가 발생할 때, 해결합니다.
    - 무시: 회복과정의 성능저하가 심하다면 그냥 무시합니다.
    
    기아상태(Starvation): 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스가 영원히 자원 할당이 되지 않는 경우입니다.
    
    우선순위를 변경합니다.(우선순위를 수시로 변경하거나, 오래 기다린 프로세스의 우선순위를 높여주거나, Queue를 사용합니다.)
    

**병렬 프로그래밍을 할 때 어떤 부분을 유의해야 하나요? 세마포어와 뮤텍스에 대해 알고 있나요? 생길 수 있는 문제는?**

- 정답
    
    뮤텍스는 한 스레드, 프로세스에 의해 소유될 수 있는 key를 기반으로 합니다. 반면 세마포어는 현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 기반으로 합니다. 뮤텍스나 세마포어를 쓰더라도 데드락이 발생할 수 있습니다.
    

1,2,3

!(깃허브 링크)[https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Operating System/DeadLock.md](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/DeadLock.md)