# 11단원 CPU스케줄링

[스케줄링에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%C2%A0%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%97%90%C2%A0%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    CPU와 같이 한정된 하드웨어 자원을 운영체제가 프로세스들에게 분배하기 위한 정책
    

[💡 CPU 스케줄링은 언제 발생합니까?](https://deious.tistory.com/290#%F0%9F%92%A1%20CPU%C2%A0%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%80%20%EC%96%B8%EC%A0%9C%20%EB%B0%9C%EC%83%9D%ED%95%A9%EB%8B%88%EA%B9%8C%3F-1)

- 정답
    
    실행 → 대기
    
    실행 → 준비
    
    대기 → 준비
    
    종료
    
    될때 CPU스케줄링이 발생한다. 즉 CPU가 유휴상태일때(CPU가 작업을 하지 않을 때, 다음 프로세스를선택할 때)
    

[💡 CPU 스케줄링의 목적은 무엇입니까?](https://deious.tistory.com/290#%F0%9F%92%A1%C2%A0CPU%C2%A0%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98%20%EB%AA%A9%EC%A0%81%EC%9D%80%20%EB%AC%B4%EC%97%87%EC%9E%85%EB%8B%88%EA%B9%8C%3F-1)

- 정답
    
    CPU 스케줄링은 CPU 자원을 효율적으로 사용해 처리량 향상과 응답 속도를 보장하여 시스템의 전반적은 성능을 향상하기 위해 필요합니다.  
    

[💡 스케줄링은 어떻게 분류합니까?](https://deious.tistory.com/290#%F0%9F%92%A1%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%80%20%EC%96%B4%EB%96%BB%EA%B2%8C%20%EB%B6%84%EB%A5%98%ED%95%A9%EB%8B%88%EA%B9%8C%3F-1)

- 정답
    
    스케줄링 시점에 따른 분류로 보면 선점형 스케줄링과 비선점형 스케줄링이 있습니다. 선점형 스케줄링은 필요에 따라 CPU를 사용 중인 프로세스를 강제로 중단시키고, 다른 프로세스에게 CPU를 할당할 수 있는 방식입니다. 반대로 비선점 프로세스는 프로세스가 CPU를 할당받으면, 그 프로세스가 종료되거나 I/O 작업을 위해 자발적으로 CPU를 반환할 때까지 실행됩니다. 선점형 스케줄링은 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생하고 비선점형 스케줄링은 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없다는 장단점이 존재합니다.
    

[💡 CPU 스케줄링의 종류를 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%C2%A0CPU%C2%A0%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98%20%EC%A2%85%EB%A5%98%EB%A5%BC%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    CPU 스케줄링에는 크게 비선점 스케줄링과 선점 스케줄링이 있습니다.
    
    비선점 스케줄링 : FCFS, SJF, HRN, Deadline, Priority
    
    선점 스케줄링 : SRT, 선점 우선순위, RR, MLQ, MLFQ, RM, EDF
    
    <각 스케줄링 기법의 특징은 위 링크 해설 보기>
    

 [선점 스케줄링과 비선점 스케줄링의 차이점에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%EC%84%A0%EC%A0%90%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EA%B3%BC%20%EB%B9%84%EC%84%A0%EC%A0%90%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)'

- 정답
    
    선점 스케줄링은 하나의 프로세스가 CPU자원을 사용할 때 운영체제가 강제로 CPU를 빼았는 방식입니다. 문맥교환이 발생하는 오버헤드가 존재합니다. 비선점 스케줄링은 CPU를 할당한 뒤 프로세스가 끝날때까지 CPU를 빼앗을 수 없는 기법입니다. 한번에 하나의 프로세스만 실행할 수 있습니다.
    

 [스케줄링 알고리즘의 평가 기준을 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98%20%ED%8F%89%EA%B0%80%20%EA%B8%B0%EC%A4%80%EC%9D%84%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    스케줄링 알고리즘의 평가 기준은 시스템 성능과 효율성을 측정하는 다양한 지표를 포함합니다. 주요 평가 기준으로는 CPU 이용률 , 처리량, 응답 시간, 대기 시간, 반환 시간이 있습니다. 
    
    **CPU 사용률(Utilization)**
    
    전체 시스템 시간 중에서 **CPU가 작업을 처리하는 시간의 비율**입니다.
    
    유휴 시간이 적을수록 CPU 사용률이 높습니다.
    
    CPU 사용률을 극대화하려는 많은 노력이 있지만 현재는 90% 정도가 최대 사용률이라고 합니다.
    
    **처리량(Throughput)**
    
    CPU가 **단위 시간당 작업을 마친 프로세스의 수** 입니다.
    
    CPU 사용률이 높고 프로세스들에 적정한 시간을 공평하게 제공했다면 처리량이 높습니다.
    
    정확한 계산은 어려운 편이라고 합니다.
    
    **응답 시간(Response Time)**
    
    대화식 시스템에서 **요청 후 응답이 오기 시작할 때까지의 시간**입니다.
    
    짧을수록 좋습니다.
    
    **대기 시간(Waiting Time)**
    
    **프로세스가 준비(ready) 큐에서 대기하는 시간들의 총합**입니다.
    
    대기시간이 짧을수록 좋습니다.
    
    **반환 시간(Turnaround Time) [ 대기 시간 + 실행 시간]**
    
    프로세스의 시작부터 끝날 때까지 걸리는 시간입니다.
    

[💡 전면 프로세스, 후면 프로세스에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%EC%A0%84%EB%A9%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%2C%20%ED%9B%84%EB%A9%B4%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    전면 프로세스는 GUI를 사용하는 OS에서 화면 맨 앞에 놓인 프로세스를 말합니다.  현재 입출력을 사용하는 프로세스이며 사용자와 상호작용이 가능합니다.
    
    후면 프로세스는 사용자와 상호작용이 없는 프로세스입니다. 
    

[💡 인터럽트에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%C2%A0%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말합니다.
    
    인터럽트는 크게 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.
    

[💡 하드웨어 인터럽트에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%C2%A0%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    하드웨어 인터럽트는 CPU 외부의 디스크 컨트롤러나 주변장치로부터 요구되는 것으로,운영체제의 처리를 요하는 상황을 알리기 위해 전기적인 신호를 사용해 구현됩니다.
    

[💡 소프트웨어 인터럽트에 대해 설명해주세요.](https://deious.tistory.com/290#%F0%9F%92%A1%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%97%90%20%EB%8C%80%ED%95%B4%20%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94.-1)

- 정답
    
    소프트웨어 인터럽트는 외부가 아닌 CPU 내부에서 자신이 실행한 명령이나 CPU의 명령 실행에
    
    관련된 모듈이 변화하는 경우 발생합니다.
    
    프로그램 실행 중 프로그램 상의 처리 불가능한 오류나 이벤트를 알리기 위한 경우 발생하는데,
    
    이를 트랩(trap) 또는 예외(exception)라 부릅니다.
    
    또한 프로그램 내에서 특별한 서비스를 요구하거나 감시(supervisor)를 목적으로 의도적으로
    
    프로그램이 발생시킨 특별한 명령어에 의해 발생되기도 한다.
    

- 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?
    - 
- 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?
    - 알고리즘 자체는 같다
    - 
    
    ### User Level Thread
    
    - 프로세스 내의 Thread 관련 Library가 Thread를 관리한다.
    - User Level Thread의 존재를 Kernel에서는 알지 못한다.
    - 모든 관리에 커널이 관여하지 않기 때문에 가볍게 쓰레딩을 할 수 있다.
    - 하나의 Thread라도 동작을 멈출 경우, 그 프로세스 전체가 Block된다.
    - 멀티 프로세서를 전혀 이용할 수 없다.ex. new Thread() 같이 프로세스 내에서 Thread를 생성하는 것
    
    ### 장점
    
    - 스케줄링이나 동기화를 위해 커널을 호출하지 않기 때문에 인터럽트 발생 시 오버헤드가 적다.
    - 커널은 사용자 스레드의 존재를 모르기 때문에 모드 전환이 없다.
    
    ### 단점
    
    - 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다. (무슨 스레드가 먼저 동작할 지 모름. -> Thread 생성 시 우선순위를 정할 순 있지만 정확하지 않다.)
    - I/O 작업 등에 의해 하나라도 Block된다면 전체 스레드가 Block된다.
    
    ### Kernel Level Thread
    
    - 스케줄링하는 주체가 커널이다.
    - 커널이 모든 프로세스와 스레드를 관리하는 것을 의미한다.
    - Thread Table이 커널에 합쳐져 하나만 존재한다.
    - 각 프로세서에서 다른 두 개의 쓰레드를 실행할 수 있다.
    
    ### 장점
    
    - 프로세스의 스레드들을 프로세서에 **한번에 디스패치** 할 수 있기 때문에 멀티프로세서 환경에서 매우 빠르게 동작한다.
    - 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
    
    ### 단점
    
    - 스케줄링과 동기화를 위해 커널을 호출하는데 무겁고 오래걸린다.
    - 사용자 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생한다.
- 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
- 정답
    
    같은 방식같은데…………
    
- FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요? ([문제 링크](https://github.com/VSFe/Tech-Interview/blob/main/02-OPERATING_SYSTEM.md#10-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EB%90%98%EC%96%B4-%EC%8B%A4%ED%96%89%EB%90%98%EB%8A%94-%EA%B3%BC%EC%A0%95%EC%9D%84-%EA%B0%84%EB%9E%B5%ED%95%98%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94))
    - 정답
        - 모든 작업이 거의 동일한 크기이고, 응답시간보다는 처리량이 중요한 경우에 F
- 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?
    - 정답
        - 여러개의 큐 활용 : 프로세스 특성에 따라 다른 우선순위를 부여하여 단일 레벨 스케줄러에 비해 다른 특성을 가진 프로세스를 효과적으로 관리합ㅂ니다.
        - 우선순위 부여 : FJFS에서 발생하는 호위효과를 방지
        - 큐 간 이동 가능 : 우선순위가 낮은 작업이 기아 상태에 빠질 수 있는 문제 방지
    
- 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
    - 정답
        1. 싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스를 효과적으로 관리하기 위해서는 우선순위 기반 스케줄링 알고리즘을 사용하는 것이 좋습니다. 이는 중요한 프로세스가 항상 필요한 CPU 시간을 확보하고, 시스템의 응답 시간을 개선하며, 자원을 효율적으로 배분할 수 있도록 합니다. 단, 기아 문제를 방지하기 위한 추가적인 기법도 고려해야 합니다.
        2. 우선순위를 기반으로 할당하는 MLFQ, 짧은 타임 Slice로 동시에 실행하는것처럼 느낄 수 있는 RR 등이 있습니다
- RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
    - 정답
        - 타임슬라이스가 짧을 때
            - 높은 응답성 : 각 프로세스가 빠르게 CPU를 얻을 수 있다.
            - 공평성 증가 : 모든 프로세스가 자주 CPU를 할당받을 수 있다.
            - 문맥 전환 오버헤드 증가 : CPU 시간이 문맥전환 오버헤드로 많이 소모되며 프로세스 실행 시간이 줄어들어 시스템의 전반적인 처리량이 낮아진다.
        - 타임 슬라이스가 길 때
            - 문맥 전환 오버헤드 감소
            - 응답성 저하
            - 비공평성 증가
- 단기, 중기, 장기 스케줄러에 대해 설명해주세요
    - 정답
        
        단기 : CPU스케줄링입니다. 어떤 프로세스가 CPU를 할당받을지 운영체제가 판단할 때 쓰입니다.
        
        중기 : 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아내며 현재 메모리에 너무 많은 프로세스가 올라가있지 않게 조절한다
        
        장기 : 메모리와 디스크 사이의 스케줄링 기법입니다. 어떤 프로세스를 메모리에 적재할지 판단할 때 사용됩니다.
        
- **현대 OS에는 단기, 중기, 장기 스케줄러를 모두 사용하고 있나요?**
    - 정답
        - **장기 스케줄러** : 사용하지 않는다.
            - 장기 스케줄러는 일괄처리 시스템에서 사용한다. (자원 독점)
            - 현대 운영체제에서는 대부분 시분할 방식인 Round Robin을 사용한다. (자원 독점X)
                - 시분할 방식에서 프로세스는 시작과 동시에 메모리를 할당해 Ready Queue 에 넣는다.
            - 가상 메모리의 사용으로 잘 사용하지 않는다.
        - **중기 스케줄러** : 잘 사용하지 않는다
            - 가상메모리를 사용하면 프로세스의 전체가 아닌 일부만 실제 메모리에 올라와도 된다.
            - 따라서 실제 메모리 용량보다 큰 프로그램을 실행 시킬 수 있고 메모리의 크기에 제약이 없어졌다.
        - **단기 스케줄러** : 여전히 사용한다.
- 프로세스의 스케쥴링 상태에 대해 설명해 주세요.
    - 정답
        
        생성, 준비, 실행, 대기, 종료 상태가 있습니다.
        
        생성 상태는 프로새스가 생성된 상태입니다.
        
        준비 상태는 실행하기 전에 기다리는 상태를 말합니다.
        
        실행 상태는 프로세스를 실행중인 상태를 말합니다.
        
        대기 상태는 프로세스가 대기하는 상태로 완료 인터럽트가 오면 대기 상태에서 레디 상태로 상태를 바꾸고 대기 큐에서 제거합니다.
        
- preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
- 정답
    
    ### 비선점형 스케줄링에서 존재할 수 없는 상태:
    
    - **Running → Ready**: 비선점형 스케줄링에서는 실행 중인 프로세스가 스스로의 의지 없이 준비 상태로 전환될 수 없습니다. 이는 운영체제가 현재 실행 중인 프로세스를 강제로 중단시키지 않기 때문입니다. 프로세스는 오직 자발적으로 종료하거나 블록 상태로 전환될 때만 CPU를 포기합니다.
    
    ### 선점형 스케줄링에서 존재할 수 없는 상태:
    
    - 선점형 스케줄링에서는 모든 상태 전환이 가능합니다.
    

https://howudong.tistory.com/299

싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스를 관리할 때 가장 적합한 스케줄링 알고리즘은 **우선순위 스케줄링 (Priority Scheduling)**입니다. 그 이유는 다음과 같습니다:

1. **상시로 돌아가는 프로세스의 중요성**: 상시로 돌아가야 하는 프로세스는 시스템에서 매우 중요한 역할을 하므로, 이를 우선적으로 실행해야 합니다. 우선순위 스케줄링은 프로세스에 우선순위를 부여하고, 높은 우선순위를 가진 프로세스를 먼저 실행합니다. 따라서, 상시로 돌아가야 하는 프로세스에 높은 우선순위를 부여하면, 이 프로세스가 항상 우선적으로 실행될 수 있습니다.
2. **예측 가능성**: 우선순위 스케줄링을 사용하면 중요한 프로세스가 예측 가능하게 자원을 사용할 수 있습니다. 이는 시스템의 안정성과 신뢰성을 높이는 데 도움이 됩니다.
3. **긴급 상황 대응**: 시스템에 긴급한 작업이나 중요한 작업이 발생했을 때, 우선순위 스케줄링을 통해 즉시 해당 작업을 처리할 수 있습니다. 이는 상시로 돌아가야 하는 프로세스가 긴급하게 처리해야 할 작업을 놓치지 않도록 보장합니다.

따라서, 상시로 돌아가야 하는 프로세스가 있는 싱글 스레드 CPU 환경에서는 **우선순위 스케줄링 (Priority Scheduling)**을 사용하는 것이 좋습니다. 이 스케줄링 알고리즘은 중요한 작업을 우선적으로 처리하여 시스템의 안정성과 효율성을 보장할 수 있습니다.