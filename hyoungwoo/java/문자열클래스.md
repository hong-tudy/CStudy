- 자바에서 Char 타입의 불편함을 해소 시켜주는 매우 편리한 존재
- 원시타입이 아닌 참조형 객체 클래스
- 불변성
    - 스트링 클래스 내부를 까보면 결국은 Char 배열로 생성된 불변 객체 값
        
        ```java
            @Stable
            private final byte[] value;
        ```
        
- 선언하는 방법은 두 가지
    - 리터럴
        - 리터럴로 선언된 String 클래스는 선언시 객체가 문자열 상수풀에 저장
    - new를 사용한 선언
        - JVM의 Heap 영역에 저장
- String은 객체이기 때문에  단순비교인 `==` 로는 두 객체의 값을 비교할수는 없음
- 문자열 상수풀에 저장된 문자열은 재생성 시에 불변 객체이기 때문에 미리 `intern()` 메서드에서 탐색이 되어 미리 생성된 객체가 공유되어 단순 비교인 == 에 true 값이 나오게 됨
    - **intern()**
        - String constant pool 에서 문자열을 조회하여 존재시 그 객체를 반환, 아닐 경우 등록 하는 메서드
        - 이를 통해 불변객체가 가지는 동일한 객체를 공유할 수 있는 특징을 사용할수 있고 동일한 객체가 하나만 생기게 할수도 있음
- String이 Immutable이라서 얻는 장점
    - 불변성의 장점으로 불변의 객체이기에 객체에 접근하거나 매개변수로 전달해도 해당 객체의 내용이 변경되지 않는 안정성
    - 프로그램 안정성, 스레드 안정성, 보안성 등에 장점을 제공하며 자료구조의 키로 활용하기에도 적합
    - 리터럴로 선언할 경우, JVM 내부에서 자주 사용하는 문자열 리터럴을 캐싱하기 때문에 같은 문자열을 여러번 사용하는 경우 메모리를 절약할 수 있다는 장점
- 문자열의 가변성 문제
    - 문자열이 불변이기 때문에, 문자열을 자주 변경해야 하는 경우 새로운 객체가 계속 생성되어 메모리와 성능에 부담
    - 이런 경우, `StringBuilder` 또는 `StringBuffer`를 사용하는 것이 효율적

### `StringBuilder` 클래스

- 가변성
    - `StringBuilder`는 가변(Mutable) 객체로, 문자열을 변경할 수 있음
    - 메모리를 절약하고, 성능을 향상시키기 위해 자주 사용
    - 문자열을 반복적으로 추가하거나 변경해야 하는 경우 유용
- 비동기 환경에서의 한계
    - `StringBuilder`는 동기화되지 않아서, 여러 스레드가 동시에 접근하는 경우 문제가 발생할 수 있음
    - 멀티스레드 환경에서는 `StringBuffer`를 사용하는 것이 안전

### `StringBuffer` 클래스

- `StringBuffer`는 `StringBuilder`와 마찬가지로 가변 객체지만, 모든 메서드가 동기화(synchronized)되어 있음
- 멀티스레드 환경에서 안전하게 사용 가능
- `StringBuffer`는 동기화된 메서드 때문에 `StringBuilder`보다 성능이 떨어질 수 있습니다. 따라서 동기화가 필요하지 않은 경우에는 `StringBuilder`를 사용하는 것이 더 효율적