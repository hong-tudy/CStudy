# 자바 base

- 자바의 특징
    - JVM(Java Virtual Machine) 위에서 동작하며 운영체제에 독립적
        - 자바 프로그램은 JVM 위에서 실행되는데, 이는 자바 애플리케이션이 JVM을 실행할 수 있는 어떤 운영체제에서든지 실행될 수 있음을 의미
        - "Write Once, Run Anywhere"(한 번 작성하여 어디서든 실행)
        - 개발자는 특정 운영체제에 종속되지 않고 애플리케이션을 개발할 수 있으며, 이는 애플리케이션의 이식성을 크게 향상
        - JVM은 자바 바이트코드를 운영체제가 이해할 수 있는 기계어로 변환하는 역할을 하며, 이 과정에서 운영체제 간의 차이점을 추상화
    - 매니지드 언어로서의 가비지 컬렉션
        - 자바 가상 머신(JVM)이 메모리 관리, 스레드 관리 등 애플리케이션 실행에 필요한 다양한 시스템 리소스 관리를 대신 수행한다는 의미
        - 가비지 컬렉터는 더 이상 사용되지 않는 메모리(가비지)를 자동으로 검출하고 회수하는 역할
        - 개발자는 메모리 누수(memory leak)와 같은 문제에 대한 걱정을 덜고, 애플리케이션 개발에 더 집중할
        - 하지만, 가비지 컬렉션 동작 시점은 예측할 수 없으며, 컬렉션 과정 중에는 애플리케이션의 일시적인 정지가 발생
    - 객체지향 프로그래밍 언어
        - 객체지향 프로그래밍(Object-Oriented Programming, OOP) 패러다임을 기반
        - 프로그램을 객체라는 기본 단위로 구성하고, 이 객체들이 서로 상호작용하도록 설계하는 방법
        - 자바의 객체지향적 특성은 코드의 재사용성, 확장성, 유지보수성을 향상
        - 상속, 다형성, 캡슐화와 같은 객체지향의 핵심 개념을 완전히 지원함으로써, 복잡한 문제를 보다 효율적으로 해결
    - 그외 특징
        - **강력한 표준 라이브러리: Java는 방대한 표준 라이브러리를 제공합니다. 이 라이브러리들은 네트워킹, 파일 입출력, 데이터 구조, 그래픽 사용자 인터페이스(GUI) 생성 등 다양한 기능을 포함하고 있습니다. 이로 인해 개발자들은 표준화된 코드를 사용하여 더 빠르고 효율적으로 개발할 수 있습니다.**
        - **멀티스레딩 지원: Java는 멀티스레딩을 내장 지원합니다. 이는 하나의 프로그램이 동시에 여러 작업을 수행할 수 있게 해주며, 이는 특히 네트워크 작업과 대규모 계산 작업에 유용합니다. 자바의 멀티스레딩 모델은 프로그램의 성능을 크게 향상시킬 수 있습니다.**
        - **보안: Java는 보안을 매우 중요시합니다. JVM은 실행 중인 코드를 여러 가지 검사를 통해 검증하며, 자바의 보안 모델은 네트워크와 파일 시스템 접근 제어를 포함합니다. 또한, 자바는 공개 키 인증, 암호화, 안전한 통신 등을 위한 API를 제공합니다.**
        - **플랫폼 독립성: Java 바이트코드는 플랫폼에 독립적입니다. 이는 자바 프로그램이 한 플랫폼에서 컴파일되면 어떤 JVM이 설치된 시스템에서든 실행될 수 있다는 것을 의미합니다. 이 특성은 자바의 "Write Once, Run Anywhere" 철학을 가능하게 합니다.**
        - **예외 처리: Java는 강력한 예외 처리 기능을 제공합니다. 예외 처리를 통해 프로그램의 오류를 쉽게 관리하고 처리할 수 있으며, 이는 프로그램의 안정성과 신뢰성을 향상시킵니다.코드의 간결성과 명확성: Java는 가독성이 높고 쓰기 쉬운 언어로 설계되었습니다. 이는 코드의 유지 보수를 용이하게 하며, 개발자 간의 협업을 촉진합니다.**
- JVM과 가비지 컬렉터의 성능적인 문제
    - JVM의 오버헤드
        - 시작 시간: JVM이 시작되고, 클래스들이 로드되며, 초기화되는 과정에서 시간이 소요됩니다. 이는 특히 짧은 작업을 수행하는 애플리케이션에서 상대적으로 더 큰 오버헤드를 유발
        - 메모리 사용: JVM은 실행되는 Java 프로그램에 필요한 메모리를 관리, 이 과정에서 JVM 자체의 메모리 사용량이 추가되어, 전체적으로 더 많은 메모리를 필요, 특히, 작은 장치나 메모리가 제한된 환경에서는 문제
    - 가비지 컬렉션의 성능 문제
        - 가비지 컬렉션(GC) 지연: 가비지 컬렉터가 동작할 때, 메모리에서 사용되지 않는 객체들을 찾아 제거
            - 이 과정에서 애플리케이션의 실행이 일시적으로 멈출 수 있으며, 이는 "GC 퍼즈"라고 불림
            - 대규모 데이터를 다루는 애플리케이션에서는 GC가 빈번하게 발생할 수 있으며, 이로 인해 성능 저하가 발생
        - 메모리 관리 오버헤드: 가비지 컬렉션은 메모리를 자동으로 관리하지만, 이 과정에서 추가적인 계산이 필요
            - 메모리 관리에 대한 세밀한 통제가 필요한 경우, 가비지 컬렉션이 오히려 성능 저하의 원인이 될 수 있음
    - 성능 문제를 최소화하기 위해, Java와 JVM은 지속적으로 개선되고 있으며, 가비지 컬렉션 알고리즘의 효율성 개선, JIT(Just-In-Time) 컴파일러의 최적화, GraalVM과 같은 새로운 기술의 도입 등을 통해 성능 문제를 해결하려는 노력이 이루어지고 있음
    - 애플리케이션의 성능을 최적화하기 위해 적절한 가비지 컬렉터 선택, 효율적인 코드 작성 방법, JVM 튜닝 등을 고려할 수 있음
- 가비지 컬렉터
    - 사용되지 않는 객체를 자동으로 감지하고, 그 객체가 차지하고 있던 메모리를 회수
    - 이 과정을 통해 메모리 누수(memory leak)를 방지하고, 프로그램이 더 긴 시간 동안 안정적으로 실행
    - 참조 소멸과 접근 불가능 상태
        - 참조하는 변수가 스코프를 벗어나거나, 참조 변수가 다른 객체를 가리키도록 변경될 때 이런 상황이 발생
    - 가비지 컬렉션의 실행
        - 가비지 컬렉터는 주기적으로 또는 메모리가 부족할 때 실행
        - 가비지 컬렉터는 프로그램에서 더 이상 접근할 수 없는 객체를 찾아내고, 이러한 객체가 차지하고 있던 메모리를 회수
    - 알고리즘
        - 마크 앤 스위프
            - '루트 집합'(Root Set)으로부터 시작하여 참조되고 있는 객체를 탐색
            - 루트 집합이란, 스택(지역 변수), 정적 영역(클래스에 속한 정적 변수), 네이티브 스택(JNI 코드에서의 참조 등)에서 참조되는 객체들을 의미
            - 루트 집합으로부터 접근할 수 있는 모든 객체들은 '살아있는 객체'로 간주되며 마킹 과정을 통해 표시
            - JVM은 객체 그래프를 탐색하며, 각 객체를 참조하는 루트가 있는지 확인
            - 마킹 단계에서 살아있는 것으로 표시되지 않은 객체들은 더 이상 사용되지 않는 것으로 간주
            - 스윕 단계에서는 이러한 마킹되지 않은 객체들을 힙 메모리에서 제거
            - 상대적으로 구현이 간단하고, 메모리를 효율적으로 관리
        - 컴팩션
            - 메모리의 단편화를 줄이기 위해, 살아있는 객체를 힙 메모리의 한 쪽으로 모으고, 비어 있는 공간을 메모리의 한 쪽으로 집중
            - 객체를 이동시키고 포인터를 업데이트하여 연속적인 메모리 블록을 확보
        - 복사
            - 객체를 두 개의 영역(예: 새 영역과 오래된 영역)으로 나누고, 살아있는 객체를 새 영역으로 복사
            - 메모리 단편화를 줄이고, 새로운 객체가 새로운 메모리 블록에 저장되어 효율적인 메모리 관리를 가능
        - 세대별 가비지 컬렉션
            - 객체의 생존 기간에 따라 메모리를 여러 영역으로 나누어 관리함으로써 효율성을 높힘
            - **영 세대 (Young Generation):**
                - 짧은 생명 주기를 가진 객체가 위치하며, 주기적으로 가비지 컬렉션이 발생
            - **노인 세대 (Old Generation):**
                - 상대적으로 긴 생명 주기를 가진 객체가 위치하며, 영 세대에서 오래된 객체가 이동
    - 버젼별 GC
        - Java 8
            - 초기에는 G1 GC와 CMS GC가 주요 알고리즘으로 사용
        - Java 11
            - Java 11에서 ZGC가 도입
        - Java 17
            - Java 17에서는 ZGC와 Shenandoah GC가 정식으로 채택
        - Java 21
            - Java 21에서는 ZGC와 Shenandoah GC의 성능과 안정성이 더욱 향상되었으며, G1 GC의 성능 조정도 추가
- 기본 데이터 타입
    - 자바의 기본 자료형은 문자형인 char, 정수형인 byte, short, int, long, 실수형인 float, double, 논리형인 boolean으로 구성
    - 자바에서 미리 정의된 타입으로, 객체가 아니며 스택 메모리에 값을 직접 저장
        - 한글 글자의 메모리는 utf-8을 사용한다면 3바이트
        - float과 double의 유효숫자
            - float은 약 7자리, double형은 15자리
        - 일반적으로, 정밀한 계산이 필요하지 않고 메모리 사용량을 최소화해야 하는 경우에는 `float`을 사용하고, 더 높은 정밀도가 필요한 경우에는 `double`을 사용하는 것이 좋음
- 데이터 타입 간의 자동 변환(묵시적 변환)
    - 작은 자료형에서 큰 자료형으로의 자동 변환
        - 산술 연산을 수행할 때 작은 크기의 자료형은 큰 크기의 자료형으로 자동 변환
    - 정수 자료형과 실수 자료형 간의 자동 변환
        - 정수 자료형과 실수 자료형 간에 산술 연산을 수행할 경우, 정밀도가 더 낮은 정수 자료형은 정밀도가 더 높은 실수 자료형으로 자동 변환
    - 정수 자료형 간의 자동 변환
        - 서로 다른 정수 자료형 간의 산술 연산이 발생할 경우, 크기가 더 작은 정수 자료형은 크기가 더 큰 정수 자료형으로 자동 변환
- JVM 메모리 구조
    - 메소드 영역
        - 모든 스레드가 공유하는 영역으로, 클래스 정보, 상수, 정적 변수(static variables) 등이 저장
        - JVM이 시작할 때 생성되며, 로드된 클래스와 인터페이스에 대한 메타데이터를 포함
        - 런타임 상수 풀(runtime constant pool)도 이 영역에 위치하며, 각 클래스와 인터페이스의 상수와 메소드 및 필드 참조를 저장
    - 힙(Heap)
        - 역시 모든 스레드에 의해 공유되는 영역으로, 객체와 배열과 같은 인스턴스 데이터를 저장
        - 가비지 컬렉터(Garbage Collector)의 주요 작업 영역
        - 힙은 런타임에 동적으로 할당되며, 객체가 더 이상 참조되지 않을 때 가비지 컬렉션에 의해 자동으로 해제
    - 스택(Stack) 영역
        - 각 스레드마다 별도로 존재하는 영역으로, 스레드의 실행에 필요한 메소드 호출과 로컬 변수 등을 저장
        - 스레드가 생성될 때마다 각 스레드별로 별도의 스택이 생성
        - 이 스택은 메소드 호출 시 마다 프레임(Frame)이 추가(push)되고, 메소드 호출이 끝나면 해당 프레임이 제거(pop)
    - PC(프로그램 카운터) 레지스터
        - 스레드마다 하나씩 존재하는 영역으로, 현재 실행 중인 JVM 명령어의 주소
        - 스레드가 어떤 명령어를 실행하고 있는지를 추적
    - 네이티브 메소드 스택(Native Method Stack)
        - 각 스레드마다 별도로 존재하는 영역으로, Java가 아닌 다른 언어로 작성된 네이티브 코드를 실행하기 위한 영역
        - Java 네이티브 인터페이스(Java Native Interface, JNI)를 통해 네이티브 메소드 호출 시 사용
- String 객체의 불변성
    - 불변성의 장점으로 불변의 객체이기에 객체에 접근하거나 매개변수로 전달해도 해당 객체의 내용이 변경되지 않는 안정성
    - 프로그램 안정성, 스레드 안정성, 보안성 등에 장점을 제공하며 자료구조의 키로 활용하기에도 적합
    - JVM 내부에서 자주 사용하는 문자열 리터럴을 캐싱하기 때문에 같은 문자열을 여러번 사용하는 경우 메모리를 절약
    - 단점
        - 문자열을 변경해야하는 경우에 새로운 String 객체를 생성해야 함으로 성능과 메모리에 부담
            - **이전 객체는 가비지 컬렉션(GC)의 대상**
        - 문자열 연산이 빈번하게 일어나는 경우에는 StringBuilder와 같은 가변적인 클래스를 사용하는 것이 효율적
- **자바에서 문자열을 생성하는 방법 두 가지**
    - **new String() 방식**
        - **`new String()`을 사용하여 문자열을 생성하면, 매번 새로운 String 객체가 힙(heap) 메모리 영역에 할당**
        - **같은 문자열 값을 가지더라도, 객체의 참조 주소는 서로 다르게 됩니다. 즉, 메모리 상에서 동일한 문자열 데이터를 가진 여러 객체가 생성**
    - **"" (문자열 리터럴) 방식**
        - **문자열 리터럴을 사용하여 문자열을 생성하면, 자바는 문자열 상수 풀(String Constant Pool)이라는 특별한 메모리 영역에 해당 문자열을 저장**
        - **만약 같은 문자열 리터럴로 다른 문자열 객체를 생성하려고 하면, 자바는 새 객체를 생성하는 대신 이미 상수 풀에 존재하는 문자열 인스턴스의 참조를 반환**
    - **`new String()` 방식은 새로운 객체를 강제로 생성하기 때문에 필요한 경우가 아니라면 메모리 낭비가 될 수 있음**