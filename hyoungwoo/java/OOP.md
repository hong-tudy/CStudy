- 여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임
- 객체 지향 프로그래밍의 장점
    - 프로그램을 보다 유연하고 변경이 용이하게 만들 수 있음
    - 코드의 변경을 최소화하고 유지보수를 하는 데 유리
    - 코드의 재사용을 통해 반복적인 코드를 최소화하고, 코드를 최대한 간결하게 표현
- 클래스와 객체
    - 클래스
        - 객체를 생성하기 위한 틀 또는 설계도
        - 속성(Attributes)과 메소드(Methods)를 정의
    - 객체
        - 클래스에 정의된 속성과 메소드를 실제로 가지는 인스턴스
- **객체 지향 프로그래밍의 4가지 특징**
    - 캡슐화
        - **객체의 세부 구현 내용을 외부에 숨기고, 필요한 부분만을 외부에 노출**
        - **데이터 보호와 은닉을 통해 객체의 독립성을 보장**
        - 접근제어자
            - 클래스 또는 클래스의 내부의 멤버들에 사용되어 해당 **클래스나 멤버들을 외부에서 접근하지 못하도록 접근을 제한하는 역할**
                - **`public` , `default`, `protected`, `private`**
                - **`getter/setter`**
    - 상속
        - 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소
        - 한 클래스가 다른 클래스의 속성과 메소드를 물려받는 것을 의미
            - 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용
        - 코드의 재사용성을 높이고, 중복을 줄임
    - 다형성
        - **같은 이름의 메소드나 속성이 상황에 따라 다른 방식으로 동작할 수 있게 하는 특성**
        - **어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성**
        - 오버라이딩 & 오버로딩
            - 오버라이딩
                - **자식 클래스가 부모 클래스로부터 상속받은 메소드의 기능을 재정의**
            - 오버로딩
                - **같은 이름의 메소드가 매개변수의 유형이나 개수에 따라 다르게 동작**
    - 추상화
        - **중요한 정보만을 추출하고 불필요한 세부 사항은 제거하여 시스템을 단순화하는 것**
        - **객체의 공통적인 속성과 기능을 추출하여 정의하는것**
        - 추상 클래스와 인터페이스
            - 추상클래스
                - **하나 이상의 추상 메소드(구체적인 구현이 없는 메소드)**
            - 인터페이스
                - **모든 메소드가 추상 메소드인 특수한 형태**
- 객체지향 설계 5대 원칙(SOLID)
    - SRP (Single Responsibility) 단일 책임 원칙
        - 클래스는 **단 한개의 책임**을 가져야 함
        - 클래스를 **변경하는 이유는 단 하나**여야 함
        - 이를 지키지 않으면, 한 책임의 변경에 의해 **다른 책임과 관련된 코드에 영향을 미칠 수** 있음→ 이렇게 되면 **유지보수가 매우 비효율적**

          > SRP 에서 이야기하는 책임이란, '기능' 정도로 생각하면 된다. 만약 한 클래스가 수행할 수 있는 기능 (책임) 이 여러 개라면, 클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다. 응집도는 높고 결합도는 낮은 프로그램을 설계하는 것이 비로소 객체지향 설계의 핵심인데, 이것이 위반되는 것이다. 새로운 요구사항이나 프로그램 변경에 의해 클래스 내부의 동작들이 연쇄적으로 변경되어야 할 수도 있다. 이는 유지보수가 비효율적이므로, 책임을 잘게 쪼개어 분리시킬 필요가 있다.
    >
    - OCP (Open-Closed) 개방-폐쇄 원칙
        - **확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함**
        - 즉, **기존의 코드를 변경하지 않고** 기능을 **수정하거나 추가**할 수 있도록 설계해야 함
        - 이를 지키지 않으면 `instanceof` 와 같은 연산자를 사용하거나, 다운 캐스팅 발생

      > OCP 는 추상화 (인터페이스) 와 상속 (다형성) 등을 통해 구현해낼 수 있다. 자주 변화하는 부분을 추상화함으로써 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 함으로써 유연함을 높이는 것이 핵심이다.
    >
    - LSP (Liskov Substitution) 리스코프 치환 원칙
        - **하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행**할 수 있어야 함→ 즉, 상위 타입 객체를 **하위 타입 객체로 치환해도 정상적으로 동작**해야 함
        - 상속관계에서는 꼭 **일반화 관계 (`IS-A`) 가 성립해야 한다는 의미** (일관성 있는 관계인지)
        - **상속관계가 아닌 클래스들을 상속관계로 설정하면, 이 원칙이 위배**됨 (**재사용 목적**으로 사용하는 경우)

      > 결국은, 리스코프 치환 원칙을 지키지 않으면 개방 폐쇄 원칙을 위반하게 되는 것이다. 기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이다. 따라서 상속 관계를 잘 정의하여 LSP 원칙이 위배되지 않도록 설계해야 한다.
    >
    - ISP (Interface Segregation) 인터페이스 분리 원칙
        - 클라이언트는 **자신이 사용하는 메소드에만 의존**해야 한다는 원칙
        - 한 클래스는 **자신이 사용하지 않는 인터페이스는 구현하지 않아야 함**→ 하나의 통상적인 인터페이스보다는 차라리 **여러 개의 세부적인 (구체적인) 인터페이스가 나음**
        - 인터페이스는 해당 인터페이스를 사용하는 **클라이언트를 기준으로 잘게 분리되어야 함**

      > 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 하는 것이 핵심이다.
    >
    - DIP (Dependency Inversion) 의존 역전 원칙
        - 의존 관계를 맺을 때, **변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존**해야 함

          > → 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다는 뜻
  >

  ## 총 정리

  **SRP 와 ISP 는 객체가 커지는 것을 막아준다**. 객체가 단일 책임을 갖도록 하고 클라이언트마다 특화된 인터페이스를 구현하게 함으로써 **한 기능의 변경이 다른 곳까지 미치는 영향을 최소화**하고, 이는 **기능 추가 및 변경에 용이**하도록 만들어 준다.

  **LSP 와 DIP 는 OCP 를 서포트**한다. OCP 는 자주 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장에는 용이하되 기존 코드의 변화에는 보수적이도록 만들어 준다. 여기서 **'변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP 이고, 다형성 구현을 도와주는 원칙이 LSP** 인 것이다.