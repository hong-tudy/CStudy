### Object Class

- 모든 Java 클래스의 최상위 부모 클래스이자, Java에서 모든 객체가 기본적으로 상속받는 클래스
- Java 언어의 기반을 형성하는 중요한 메서드들을 제공하며, 이 메서드들은 대부분의 Java 객체에서 상속받아 사용되거나 필요에 따라 오버라이딩
- 주요 클래스
    - **`equals(Object obj)`**
        - 두 객체가 동일한지를 비교하는 메서드
        - 기본적으로 메모리 주소(참조) 비교를 수행하지만, 객체의 논리적 동등성을 비교하기 위해 오버라이딩할 수 있음
            - 일반적으로 논리적으로 동일한 객체(예: 동일한 속성 값을 가진 객체)를 비교하기 위해 오버라이딩
    - **`hashCode()`**
        - 객체의 해시 코드를 반환하는 메서드
        - 해시 코드는 객체를 해시 기반의 컬렉션에서 사용할 때 중요
            - `equals()`를 오버라이딩할 때는 `hashCode()`도 반드시 함께 오버라이딩해야 함
            - 동일한 객체는 동일한 해시 코드를 가져야 하기 때문
    - **`toString()`**
        - 객체의 문자열 표현을 반환하는 메서드
        - 기본적으로 객체의 클래스 이름과 해시 코드가 포함된 문자열을 반환하지만, 의미 있는 정보 출력을 위해 오버라이딩할 수 있음
    - **`notify()`, `notifyAll()`, `wait()`**
        - 스레드 간의 통신을 위해 사용되는 메서드
        - 동기화된 블록이나 메서드 내에서 호출되어야 하며, 객체의 모니터 상태를 제어
        
        ```java
        synchronized (obj) {
            obj.wait(); // 갖고 있던 고유 lock 해제, Thread를 잠들게 함
        }
        
        synchronized (obj) {
            obj.notify(); // 잠들던 Thread 중 임의의 하나를 깨움
        }
        
        synchronized (obj) {
            obj.notifyAll(); // 잠들어 있던 Thread 를 모두 깨움.
        }
        ```
        
    - *wait, notify, notifyAll : 호출하는 스레드가 반드시 고유 락을 갖고 있어야 함.*
    - Synchronized 블록 내에서 실행되어야 함.
    - 그 블록 안에서 호출하는 경우 IllegalMonitorStateException 발생.
- **Object 클래스 메서드 오버라이딩 주의사항**
    - **`equals()`와 `hashCode()`의 일관성**
        - 두 메서드를 함께 오버라이딩할 때는 항상 두 메서드 간의 일관성을 유지
    - **`clone()`의 복잡성**
        - `clone()` 메서드는 얕은 복사와 깊은 복사의 차이를 이해하고 사용해야 하며, 모든 클래스가 복사 가능하지 않다는 점을 고려

### 캐스팅 (Casting)

- 타입을 변환하는 것
- 자동 형 변환
    - 작은 크기의 데이터 타입을 큰 크기의 데이터 타입으로 변환
    - 데이터 손실이 없기 때문에 자바에서 자동으로 수행
    - 데이터 손실이 없으므로 안전하게 수행
    - 변환된 후에도 원래 값이 유지
    - 기본적으로 아래와 같은 크기 순서로 자동 형 변환이 가능
        - `byte` -> `short` -> `int` -> `long` -> `float` -> `double`
        - `char` -> `int` -> `long` -> `float` -> `double`
- 명시적 형 변환
    - 큰 크기의 데이터 타입을 작은 크기의 데이터 타입으로 변환
    - 데이터 손실의 가능성이 있기 때문에 명시적으로 캐스팅을 수행
        - `double`을 `int`로 변환하면 소수점 이하의 값이 손실
    - 명시적으로 `(타입)`을 사용하여 변환할 타입을 지정해야 함
- 캐스팅 시 타입의 범위를 넘어서는 경우, 오버플로우 또는 언더플로우가 발생할 수 있음
- 산술 연산에서 원시형 데이터 타입들은 자동으로 형 변환이 발생
    - 두 개의 `int` 값을 나눌 때는 정수 연산이 이루어지지만, 한쪽을 `float`으로 형 변환하면 부동소수점 연산이 수행

### 업캐스팅 & 다운 캐스팅

- **다형성**을 구현할 때 자주 사용
- 업캐스팅
    - 자식 클래스가 부모 클래스 타입으로 캐스팅 되는 것
    - 서브 클래스는 수퍼 클래스의 모든 특성을 상속
        - 서브 클래스는 수퍼 클래스로 취급될 수 있음
        - 수퍼 클래스의 참조변수가 서브클래스로 객체화된 인스턴스를 가리킬 수 있게 됨
        - **부모 클래스에 정의된 메서드와 변수**만 접근할 수 있음. 자식 클래스에만 정의된 메서드나 변수에는 접근할 수 없음
- 다운 캐스팅
    - 부모 클래스가 자식 클래스 타입으로 캐스팅 되는 것.
    - 다운 캐스팅은 **명시적으로** 수행해야 하며, **캐스팅할 타입을 명시적으로 지정**해 주어야 함
    - 다운 캐스팅을 잘못 수행하면 **`ClassCastException`**이 발생할 수 있음
    - **특징**
        - 부모 클래스의 참조 변수를 자식 클래스 타입으로 변환
        - 다운 캐스팅을 통해 자식 클래스에만 있는 메서드나 변수에 접근할 수 있음
        - **런타임 시점**에 객체가 실제로 가리키는 타입이 자식 클래스와 일치하지 않으면 `ClassCastException`이 발생할 수 있음
        - 다운 캐스팅이 안전한지 확인하기 위해서는 `instanceof` 연산자를 사용할 수 있음
    - **주의사항**
        - **`instanceof` 연산자**를 사용하여 다운 캐스팅이 안전한지 확인하는 것이 좋음
            - 이 연산자는 객체가 특정 클래스의 인스턴스인지 확인하는 데 사용
        - 다운 캐스팅은 **항상 명시적**으로 이루어져야 하며, 그렇지 않으면 컴파일 오류가 발생
        - **부모 클래스 타입의 참조 변수가 실제로 자식 클래스의 인스턴스를 가리킬 때만** 다운 캐스팅이 가능
            - 그렇지 않을 경우, 다운 캐스팅은 **`ClassCastException`*을 일으킴