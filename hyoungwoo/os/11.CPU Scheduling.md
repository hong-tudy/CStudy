## CPU 스케줄링 개요

- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
- CPU 스케줄링은 컴퓨터 성능과도 직결

### 프로세스 우선순위

- 프로세스마다 우선순위가 다름
- 입출력 작업이 많은 프로세스는 우선순위가 높음
- 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에 차이가 있음
    - 입출력 집중 프로세스
        - 비디오 재생, 디스크 백업 작업
    - CPU 집중 프로세스
        - 수학 연산, 컴파일, 그래픽 처리 작업
    - 입출력 집중 프로세스는 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무르게 됨
    - CPU 버스트, 입출력 버스트
        - CPU를 이용하는 작업
        - 입출력장치를 기다리는 작업
- CPU 집중 프로세스와 입출력 집중 프로세스가 동일한 빈도로 CPU를 사용하는 것은 비합리
    - 동시에 CPU 자원을 요구할 경우 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력 장치를 작동시키고 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적
        - 입출력장치가 입출력 작업을 완료하기 전에는 어차피 대기 상태
- 상황에 맞게 프로세스 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 운영체제는 프로세스마다 우선순위 부여
    - 유닉스, 리눅스, masOS에서 `ps -el` 명령어를 통해 확인이 가능, mice 명령을 통해 우선순위 변경도 가능

### 스케줄링 큐

- PCB에 우선순위가 적혀 있지만 CPU를 사용할 다음 프로세스를 찾기 위해 모두 탐색하는건 비효율
- 스케줄링 큐로 구현하여 관리
    - 큐에 삽입하여 줄을 세움
    - 운영체제가 관리하는 대부분의 자원은 큐로 관리
        - 준비 큐(Ready Queue)
            - CPU를 이용하고 싶은 프로세스들이 서는 줄
        - 대기 큐(Waiting Queue)
            - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
    - 삽입된 순서대로 프로세스를 꺼내되 우선순위가 높은 프로세스를 먼저 실행
- 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고 해당 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거

## Process 스케줄러

<aside>
📌 각각의 Queue에 프로세스를 넣고 빼주는 스케줄러

</aside>

### 장기 스케줄러(**Long-term scheduler, Job scheduler**)

- 메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장. 대용량 메모리(일반적으로 디스크)에 임시로 저장
- 저장되어 있는 프로세스 중 **어떤 프로세스에 메모리를 할당하여 Ready Queue로 보낼지 결정하는 역할**

---

- 메모리와 디스크 사이의 스케줄링을 담당
- 프로세스에 memory(및 각종 리소스)를 할당(admit)
- degree of Multiprogramming 제어(실행중인 프로세 툐 고스의 제어)
- 프로세스의 상태(new → ready(in memory))
- 시스템에서 새로운 프로세스를 생성하는 간격은 길기 때문에 **실행 빈도수가 적다**

### **단기 스케줄러(Short-term scheduler, CPU scheduler)**

- CPU와 메모리 사이의 스케줄링을 담당
- **Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정**
    - 어느 프로세스에게 CPU를 할당할지 결정
- 프로세스의 상태(ready → running → waiting → ready)
- 단기 스케줄러는 실행 간격이 짧기 때문에 매우 빨라야하며, **실행 빈도가 잦다**

### **중기 스케줄러(Medium-term scheduler, Swapper)**

- **여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄**(Swapping)
- 프로세스에게서 Memory를 deallocate(반납)
- degree of Multiprogramming 제어
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러
- 프로세스의 상태(ready → suspended)

## CPU 스케줄러

<aside>
📌 CPU가 유휴 상태가 될 때마다 Ready Queue에 있는 프로세스를 대상으로 실행될 프로세스를 선택

</aside>

디스패치(Dispatch) : 운영체제가 프로세스를 프로세서에 할당하는 것. 프로세스 상태가 ready → running 으로 바뀜

큐에 있는 레코드들은 일반적으로 프로세스들의 PCB

---

**스케줄링이 발생하는 상황**

1. 프로세스가 실행 상태에서 대기 상태로 전환
    1. 프로세스가 현재 실행 중이지만 입출력 작업이나 특정 이벤트를 기다리기 위해 대기 상태로 전환되는 경우, CPU가 유휴 상태가 되기 때문에 다른 프로세스를 실행해야함
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환
    1. 프로세스가 현재 실행 중이지만 할당된 시간(타임 슬라이스)을 모두 사용했거나, 더 높은 우선순위의 프로세스가 등장했을 때, 준비 완료 상태로 전환되는 경우, CPU를 다른 프로세스에게 할당
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환
    1.  프로세스가 입출력 작업이나 이벤트 대기를 완료하고 다시 실행될 준비가 되었을 때, 준비 완료 상태로 돌아온 프로세스가 즉시 실행될 수 있으며, 현재 실행 중인 프로세스보다 우선순위가 높다면 교체가 필요할 수 있음
4. 프로세스 종료
    1. 현재 실행 중인 프로세스가 완료되어 종료되는 경우, CPU가 유휴 상태가 되기 때문에 다른 프로세스를 실행
- 1, 4에서만 스케줄링이 발생하면 비선점. 아니라면 선점형 스케줄링
    - **비선점형 스케줄링**: 1번(대기 상태 전환)과 4번(종료) 상황에서만 스케줄링이 발생. 현재 실행 중인 프로세스가 스스로 CPU를 반환하거나 종료될 때까지 다른 프로세스가 CPU를 사용할 수 없음
    - **선점형 스케줄링**: 1번, 2번(준비 상태 전환), 3번(대기에서 준비로 전환), 4번 상황 모두에서 스케줄링이 발생. 즉, 현재 실행 중인 프로세스가 CPU를 사용하는 도중에도 다른 프로세스가 CPU를 사용할 수 있도록 스케줄링될 수 있음

### 선점형과 비선점형 스케줄링

- 선점형 스케줄링
    - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
    - 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
- 비선점형 스케줄링
    - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식을 의미
    - 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식
- 장단점
    - 선점형 스케줄링
        - 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생
    - 비선점형 스케줄링
        - 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없음

### CPU 스케줄링 알고리즘

- 종류
    - 선입 선처리 스케줄링(FCFS 스케줄링 : First Come Served Scheduling)
        - 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
        - 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용 존재
        - 호위 효과(convoy effect)
            - 소요 시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상
    - 최단 작업 우선 스케줄링(SJF 스케줄링 : Shortest Job First Scheduling)
        - 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는
        스케줄링 방식
        - 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만 선점형으로 구현 가능
            - 선점형 최단 작업 우선 스케줄링
    - 라운드 로빈 스케줄링(Round Robin Scheduling)
        - 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식
            - 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미
        - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
        - 주의 사항
            - 타임 슬라이스가 지나치게 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지
            - 타임 슬라이스가 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지
    - 최소 잔여 시간 우선 스케줄링(SRT: Shortest Remaining Time)
        - 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 알고리즘을 합친 스케줄링 방식
        - 최소 잔여 시간 우선 스케줄링 하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택
    - 우선순위 스케줄링
        - 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는스케줄링 알고리즘
        - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
        - 최단 작업 우선 스케줄링은 작업 시간이 짧은 프로세스에 높은 우선순위를 부여하는 방식이고, 최소 잔여 시간 우선 스케줄링은 남은 시간이 짧은 프로세스에 높은 우선순위를 부여하는 방식
        - 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들에 의해 실행이 계속되서 연기될 수 있음
            - 기아(starvation)현상
        - 방지하기 위한 대표적인 기법 : 에이징
            - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식입니다
    - 다단계 큐 스케줄링(multilevel queue scheduling)
        - 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
        - 다단계 큐 스케줄링 하에서는 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리
    - 다단계 피드백 큐 스케줄링
        - 다단계 큐 스케줄링의 발전된 형태
        - 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없기 때문에 우선순위가 낮은 프로세스는 계속 연기될 여지가 있음 → 기아 현상 발생
        - 프로세스들이 큐 사이를 이동할 수 있음
        - 새로 준비 상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간（타임 슬라이스） 동안 실행 → 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행 → 또 해당 큐에서 실행이 끝나지 않는다면 프로세스는 또 다음 우선순위 큐에 삽입
            - CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐
        - 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘
        - 구현이 복잡하지만 가장 일반적인 CPU 스케줄링 알고리즘