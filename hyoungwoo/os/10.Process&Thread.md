## 프로세스 개요

- 프로그램의 명령어와 정적 데이터가 자원을 할당받고 메모리에 적재되면 프로세스 생성
    - 프로그램 : 보조 기억 장치에 존재하며 실행되기를 기다리는 명령어와 정적인 데이터의 묶음
- 포그라운드 프로세스
    - 사용자가 보는 앞에서 실행되는 프로세스
        - Ex) 텍스트 편집기, 웹 브라우저, 터미널
- 백그라운드 프로세스
    - 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
    - 사용자와 직접 상호작용하지 않고 정해진 일만 하는 백그라운드 프로세스 존재
        - **데몬(Daemon)**
            - 유닉스 및 리눅스 시스템에서 주로 사용되는 백그라운드 프로세스로, 시스템이 부팅될 때 시작되고, 종료될 때까지 실행되는 프로세스
            - Ex) `httpd`(웹 서버), `sshd`(SSH 서버), `cron`(일정 작업 실행)
        - **서비스(Service)**
            - 윈도우 시스템에서 주로 사용되는 백그라운드 프로세스로, 특정 기능을 제공하거나 시스템을 유지보수하는 역할
            - Ex) Windows Update 서비스, SQL Server, 프린트 스풀러 서비스
            - 윈도우의 HTTP 요청 IIS(Internet Information Services)
        - **작업 스케줄러(Task Scheduler)**
            - 일정 시간 또는 특정 이벤트에 따라 백그라운드에서 작업을 실행하는 시스템 구성 요소
            - Ex) `cron`(유닉스 및 리눅스), Task Scheduler(윈도우)
- 포그라운드 및 백그라운드 프로세스 전환
- **터미널 명령어**:
    - 백그라운드로 전환: 터미널에서 명령어 끝에 `&`를 붙여서 프로세스를 백그라운드에서 실행 가능
        
        ```bash
        some_command &
        ```
        
    - 백그라운드에서 포그라운드로 전환: `fg` 명령어를 사용하여 백그라운드에서 실행 중인 프로세스를 포그라운드로 전환 가능
        
        ```bash
        fg
        ```
        

### 프로세스 제어 블록(PCB: Process Control Block)

- 프로세스는 한정된 CPU 자원을 사용하기 위해 정해진 시간만큼 CPU를 이용하고 시간이 끝났음을 알리는 인터럽트(타이머 인터럽트)가 발생하면 자신의 차례를 양보하고 다음 차례가 올때까지 기다림
    - 타이머 인터럽트 : 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트
- 정의
    - **프로세스의 상태, 식별자, 프로그램 카운터 등과 같은 중요한 정보를 포함하여** 프로세스와 관련된 정보를 저장하는 자료 구조
    - 운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB를 생성**
    - 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기
- 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고 CPU를 비롯한 자원을 분배
- 담기는 정보
    - 프로세스 ID (PID)
        - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    - 레지스터 값
        - 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값
            - 레지스터(Register)
                - CPU 내부에 있는 소규모 고속 메모리
                - 데이터 저장, 명령어 실행, 주소 저장에 사용
            - 프로그램 카운터
                - CPU가 다음에 실행할 명령어의 주소를 가리키는 레지스터
                    - 현재 실행 중인 프로세스가 다음에 실행할 명령어가 저장된 메모리 위치를 가리키며, 명령어의 순차적 실행을 관리
                    - 명령어가 실행되면 프로그램 카운터는 다음 명령어의 주소를 자동으로 가져와서 업데이트, CPU는 프로그램의 다음 단계로 자동적으로 진행
            - 레지스터 값
                - 특정 프로세스가 실행하면서 사용했던 레지스터들의 현재 상태
                - 프로세스가 실행되는 동안 레지스터에 저장된 데이터, 주소, 상태 등의 정보를 포함
    - 프로세스 상태
        - 현재 프로세스의 상태
            - Ex) CPU 사용 중인지, 대기중인지
    - CPU 스케줄링 정보
        - 언제 어떤 순서로 CPU를 할당받을지에 대한 정보 기록
        - 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등
    - 메모리 관리 정보
        - 어느 메모리 주소에 저장되어 있는지에 대한 정보, 베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보
    - 사용한 파일과 입출력 장치 목록
        - 실행 과정에서 특정 입출력 장치나 파일을 사용하면 PCB에 해당 내용 기록

### 문맥 교환 (Context Switching)

- 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스 실행을 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
    - 문맥 (Context)
        - 하나의 프로세스 수행을 재개하기 위해 기억해야할 정보, PCB에 저장
- 프로세스가 CPU를 사용할 . 수있는 시간이 다 되거나 예기치 못한 상황이 발생하여 인터럽트가 발생하면 PCB에 문맥을 백업, 다음 실행의 프로세스의 문맥을 복구
- **문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리, 동시에 실행되는 것처럼 보임**
    - 문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있음
- **Context Switching Cost**
    - 많은 Cost가 필요
        - Cache 초기화
        - Memory Mapping 초기화
        - Kernel은 항상 실행되어야 한다(메모리의 접근을 막기 위해)

### 프로세스의 메모리 영역

- 사용자 영역에 프로세스 배치는 크게 4 영역으로 나뉘어 저장
- 코드 영역
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어가 저장
    - CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지(read-only)
        - 프로그램을 시작할 때 컴파일한 프로그램(기계어)가 저장되어 있고, 읽기 전용 영역이기 때문에 프로세스가 함부로 변경할 수 없고 변경 시 오류를 발생
        - 컴파일 : 프로그래머가 작성한 고수준 언어로 된 소스 코드를 컴퓨터가 이해할 수 있는 저급 언어(기계어 또는 바이트코드)로 변환하는 과정
- 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간(전역 변수)
        - 전역변수, 정적변수, 배열, 구조체 등이 저장
    - 코드 영역과 함께 크기가 변하지 않음 (정적 할당 영역)
        - 프로그램을 구성하는 명령어, 프로그램이 실행되는 동안 유지되는 데이터는 변하지 않기 때문에
    - 힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변하기 때문에 동적 할당 영역
    - Data 영역은 다시 Data(GVAR) 영역과 BSS영역을 나눌 수 있음
        - 초기화된 데이터는 Data(GVAR) 영역에 저장되고 초기화되지 않은 데이터는 BSS 영역에 저장
            - 초기화된 데이터: **프로그램이 시작될 때 이미 특정 값으로 설정된 데이터**
            - 초기화되지 않은 데이터: **프로그램 시작 시 특정 값으로 설정되지 않고, 사용되기 전까지 기본값(대부분 0)으로 설정되어 있는 데이터**
- 힙 영역
    - 프로그래머가 직접 할당할 수 있는 저장 공간
    - 힙 영역에 메모리 공간을 할당했다면 언젠간 해당 공간을 반환해야함 → 더 이상 해당 메모리 공간을 사용하지 않겠다고 운영체제에 말해주는 것
    - 메모리를 수동으로 관리해야 하기 때문에 메모리 누수와 같은 문제가 발생할 수 있으며, 관리가 복잡 (JVM에서는 가비지 컬렉터를 통해 자동 관리)
- 스택 영역
    - 데이터를 일시적으로 저장하는 공간
    - 잠깐 쓰다가 말 값이 저장되는 공간 (함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수), 자동으로 관리
    - 일시적으로 저장할 데이터는 스택 영역에 PUSH되고, 더 이상 필요하지 않은 데이터는 POP됨으로써 스택 영역에서 사라짐
        - LIFO: **스택 영역은 마지막에 들어온 데이터가 가장 먼저 나가는 구조, 이는 함수 호출과 반환 과정에서 매우 중요한 역할 (재귀 호출)**
- **동적 할당 영역**
    - 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당되고, 스택 영역은 높은 주소에서 낮은 주소로 할당

## 프로세스 상태와 계층 구조

## 프로세스 상태

- 하나의 프로세스는 여러 상태를 거치며 실행
- 생성 상태
    - 프로세스를 생성 중인 상태
    - 막 메모리에 적재되어 PCB를 할당받은 상태
- 준비 상태
    - 당장이라도 CPU를 할당받아 실행할 수 있지만, 차례가 아니기에 기다리는 상태
        - 준비 상태인 프로세스가 실행 상태로 전환되는 것(디스패치-dispatch)
- 실행 상태
    - CPU를 할당받아 실행 중인 상태
    - 할당된 일정 시간 동안만 CPU를 사용
    - 할당된 시간을 모두 사용한다면(타이머 인터럽트가 발생) 다시 준비 상태, 대기 상태
- 대기 상태
    - 프로세스가 실행 중 입출력장치를 사용하는 경우
    - 입출력 작업은 CPU에 비해 처리 속도가 느리기 때문에 입출력장치가 입출력을 끝낼 때가지(입출력 인터럽트) 기다리는 상태
    - 입출력이 완료되면 다시 준비 상태
    - 입출력 작업만 있는 것은 아니지만(특정 이벤트) 대부분의 대기 상태 원인이 입출력 작업
- 종료 상태
    - 프로세스가 종료된 상태
    - PCB와 프로세스가 사용한 메모리를 정리
- **Idle 상태**
    - Idle 상태는 시스템이 사용자 또는 자동화된 작업 요청을 처리하지 않고 대기 상태에 있는 것을 의미
    - 일반적으로 시스템 부하가 낮거나 CPU 요청이 없음을 나타냄
    - 시스템 대기 상태: Idle 상태는 시스템이 사용자 또는 자동화된 작업 요청을 처리하지 않고 대기 상태에 있는 것
    - 절전 모드: Idle 상태는 CPU가 사용되지 않을 때 휴식을 취할 수 있게 하여 에너지를 절약하고 전력 소비를 줄이는 데 기여
    - 커널 처리: 운영 체제 커널이 특정 작업을 처리하거나 대기 중인 상황에서 CPU가 Idle 상태
        - 커널이 특정 작업을 수행하는 동안 일반적인 사용자 프로세스가 실행되지 않을 때 발생

### 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성
- 부모 프로세스
    - 새 프로세스를 생성한 프로세스
- 자식 프로세스
    - 부모 프로세스에 의해 생성된 프로세스
- 서로 다른 PID를 가짐
- 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPID:Parent PID)가 기록
- 운영체제는 프로세스가 프로세스를 낳는 계층적인 구조로써 프로세스를 관리
- 데몬이나 서비스 또한 최초 프로세스의 자식 프로세스
- 최초의 프로세스
    - 시스템 부팅 과정에서 마지막에 수행되어, 커널 부팅이 끝나면 운영체제가 하드웨어의 모든 기능을 제어하게 되었을 때, 커널에 의해 생성 및 실행되는 첫 번째 프로세스
    - 유닉스-init, 리눅스-systemd, macOS-launchd
    - PID 항상 1번

### 프로세스 생성 기법

- 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성
    - fork 시스템 호출은 자기 자신 프로세스의 복사본을 만드는 시스템 호출
    - 자식 프로세스는 부모 프로세스의 자원을 상속
- 자식 프로세스는 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체
    - exec 시스템 호출은 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
    - exec 시스템 호출을 통해 새로운 프로그램으로 전환하고 나머지 영역은 초기화
- 부모 프로세스가 자식 프로세스를 fork한 뒤, 부모, 자식 exec 호출하지 않는 경우 같은 코드를 병행하여 실행하는 프로세스

## 스레드(Thread)

- 프로그램 내에서, 특히 프로세스를 구성하는 실행의 흐름 단위
- 하나의 프로세스는 여러 개의 스레드를 가질 수 있음

### 프로세스와 스레드

- 단일 스레드 프로세스
    - 실행의 흐름 단위가 하나
- 스레드 도입 후 하나의 프로세스가 한 번에 여러 일 동시 처리 가능
    - 멀티 스레드 프로세스
- 스레드
    - 스레드는 프로세스 내에서 각각 레지스터와 Stack만 따로 할당 받고 Code, Data, Heap영역은 공유
        - **스택을 스레드마다 독립적으로 할당하는 이유는?**
            - 스택은 함수 호출시 전달되는 인자, 되돌아갈 주소 값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간
            - **독립적인 실행 흐름을 추가하기 위한 최소 조건**
        - **PC Register를 스레드마다 독립적으로 할당하는 이유는?**
            - PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타낸다. 스레드는 CPU를 할당 받았다가 스케줄러에 의해 다시 선점당하는데, 이 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분가지 수행됐는지 기록을 해야 함
- 프로세스의 스레드들은 실행에 필요한 최소한의 정보를 유지한 채 프로세스 자원을 공유하며 실행

**리눅스 운영체제에서 프로세스 vs 스레드**

- 프로세스와 스레드 간에 명확한 구분을 짓지 않는 운영체제도 존재 - 리눅스
- 프로세스와 스레드 모두 실행의 문맥에서 동등하다고 간주
- 프로세스와 스레드라는 말 대신 테스크(task)로 통일

### 멀티프로세스와 멀티스레드

- 스레드 풀(Thread Pools)
    - 웹 서버는 요청을 받을 때마다 요청을 위해 새로운 스레드를 생성
    - 프로세스를 시작할 때, 일정한 수의 스레드를 미리 풀로 만들어 두는 것
    - 평소에는 기다리다가 요청이 들어오면 풀의 한 스레드에게 서비스 요청을 할당
    - 요청이 끝나면 스레드는 다시 풀로 돌아가 다음 작업을 대기
- 멀티프로세스
    - 여러 프로세스를 동시에 실행
- 멀티스레드
    - 여러 스레드로 프로세스를 동시에 실행하는 것
- 프로세스끼리는 자원을 공유하지 않지만 스레드끼리는 같은 프로세스 내의 자원을 공유
- 같은 작업을 세번 실행하는 것에 프로세스 fork을 2번 하기 vs 멀티스레드로 작업하기
    - PID를 제외한 모든 것이 동일한 프로세스 2개가 통째로 메모리에 적재 → 메모리 낭비
    - Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등 오버헤드가 발생
    - fork를 한 직후 같은 프로세스를 통째로 메모리에 중복 저장하지 않으면서 동시에 프로세스끼리 자원을 공유하지 않는 방법도 존재 (쓰기 시 복사(copy on write)기법)
    - 스레드들은 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질뿐 프로세스가 가지고 있는 자원을 공유
    - 메모리 더 효율적으로 사용, 협력과 통신에도 유리
- 멀티프로세스 환경은 하나의 프로세스에 문제가 생겨도 다른 프로세스에 지장이 적음
- 멀티스레드 환경에서 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음

**프로세스 간 통신(IPC: Inter-Process-Communication)**

- 프로세스 간 기본적으로 자원을 공유하지 않지만, 프로세스끼리도 자원 공유하고 데이터 교환 가능
- 파일을 통한 프로세스 간 통신
    - Ex) 프로세스 A는 ‘hello.txt’ 파일에 새로운 값을 쓰는 프로세스, 프로세스 B는 ‘hello.txt’ 파일을 읽는 프로세스라면 두 프로세스는 ‘hello.txt’ 파일 속 데이터를 주고받으므로 프로세스 간의 통신
- 서로 공유하는 메모리 영역을 두어 데이터를 주고 받을 수 있음
    - 프로세스 간 공유가 가능한 메모리 영역 : 공유 메모리
        - 프로세스들이 데이터를 공유하기 위해 사용하는 메모리 영역. 이 방식을 통해 프로세스들은 빠르게 데이터를 교환
- 소켓, 파이프 등을 통해 통신할 수 있음
    - 파이프(PIPE): 한 프로세스의 출력을 다른 프로세스의 입력으로 연결하는 방식. 주로 리눅스나 유닉스 시스템에서 사용
    - 메시지 전달(Message Passing)
        - 프로세스들이 소켓을 통해 메시지를 주고받음으로써 통신하는 방식. 이는 데이터를 명시적으로 전송하고 수신하는 과정을 포함