## 연속 메모리 할당

- 프로세스에 연속적인 메모리 공간을 할당하는 방식

### 스와핑

- 메모리에 적재된 프로세스들 중에 현새 실행되지 않는 프로세스를 임시로 보조 기억장치 일부 영역으로 쫓아내고 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식
- 스왑 영역
    - 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃
    - 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인
    - 스왑영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
- 스왑 아웃 되었던 프로세스가 다시 스왑 인 될 때는 이전 물리 주소와는 다른 주소에 적재될 수 있음
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있음

### 스왑 영역 확인하기

- 유닉스와 리눅스, macOS에서는 free, top 명령어 등을 통해 스왑 영역의 크기를 확인할 수 있음
- 스왑 영역의 크기와 사용 여부는 사용자가 임의로 설정 가능

### 메모리 할당

- 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식에는 여러가지 방법이 있음
- 최초 적합
    - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
    - 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 결과적으로 빠른 할당 가능
- 최적 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식
- 최악 적합
    - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식

### 외부 단편화

- 프로세스를 메모리에 연속적으로 배치하 연속 메모리 할당은 당연해보이지만 메모리를 효울적으로 사용하는 방법이 아님
- 외부 단편화 문제가 있기 때문에
    - 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생김
    - 프로세스 바깥에 생기는 빈 공간들은 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고 결국 메모리 낭비로 이어짐
- 압축
    - 메모리 조각 모음
    - 여기 저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방식
    - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기
    - 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어려움

## 페이징을 통한 가상 메모리 관리

- 프로세스를 메모리에 연속적으로 할당하는 방식은 두가지 문제 내포
    - 외부 단편화
    - 물리 메모리보다 큰 프로세스를 실행할 수 없음
- 가상 메모리
    - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    - 페이징, 세그멘테이션 기법
        - 현대 대부분의 운영체제가 사용하는 페이징 기법
    - 페이징 기법을 이용하며 외부 단편화 문제도 해결

### 페이징이란

- 만일 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당할 수만 있다면 외부 단편화는 발생하지 않음
- 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징에서도 스와핑 사용 가능
    - 페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃/스왑 인 되는 것이 아닌 페이지 단위로 스와핑
    - 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃, 실행에 필요한 페이지들은 스왑인 되는 것
    - 페이지 아웃, 페이지 인으로 부름
- 프로세스 하나를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없음
    - 일부 페이지만 적재하고 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둠
    - 물리 메모리보다 더 큰 프로세스 실행 가능

### 페이지 테이블

- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없음
    - 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기란 어렵기 때문
    - 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 ‘다음에 실행할 명령어 위치’를 찾기가 어려워짐
- 이를 해결하기 위해 페이징 시스템은 물리 주소에 불연속적으로 배치되더라도 （CPU가 바라보는 주소인） 논리 주소에는 연속적으로 배치되도록 페이지 테이블 page table을 이용
    - CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 함
    - 프로세스들이 메모리에 분산되어 저장되어 있더라도 CPU는 논리 주소를 그저 순차적으로 실행하면 됨
- 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재
- CPU 내의 페이지 테이블 베이스 레지스터(Page Table Base Register (이하PTBR))는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
    - 각 프로세스의 PCB에 기록
    - 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경
- 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어나는 문제 발생
    - 페이지 테이블을 보기 위해 한번, 프레임에 접근하기 위해 한번
- TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 CPU 곁에 둠
    - 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 페이지 테이블 내용의 일부를 저장
    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트
    - 페이지 번호가TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 경우 TLB 미스

### 내부 단편화

- 페이징은 외부 단편화 문제를 해결할 수 있지만 내부 단편화(internal fragmentation)라는 문제를 야기
- 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아님
    - 모든 프로세스 크기가 페이지의 배수는 아님
    - 가령 페이지 크기가 10KB인데 프로세스의 크기가 108KB라고 해볼까요? 이 경우 마지막 페이지는 2KB만큼의 크기가 남음
    - 이러한 메모리 낭비를 내부 단편화라 함
- 페이지 크기가 작으면 발생하는 내부 단편화의 크기가 작아질 것으로 기대
    - But 하나의 페이지 크기를 너무 작게 설정하면 페이지 테이블이 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비
- 리눅스를 포함한 일부 운영체제에서는 기본적으로 설정된 페이지 크기보다 더 큰 크기의 페이지도 일부 허용하여 메모리에 유지하는 경우
    - 대형 페이지

### 페이징에서의 주소 변환

- 하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있기 때문에 특정 주소에 접근하려면 두 가지 정보 필요
    - 어떤 페이지 혹은 프레임에 접근하고 싶은지
    - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위로 이루어져 있음
    - CPU가 32비트 주소를 내보냈다면 이 중 N비트는 페이지 번호, 32-N비트는 변위
- 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있음
    - 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보
    - 즉, 논리 주소는 페이지 테이블을 통해 물리 주소로 변환

### 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행들을 페이지 테이블 엔트리(PTE)라고 함
- 페이지 테이블 엔트리에는 페이지 번호, 프레임 번호 이외에도 다른 중요한 정보들이 있음
    - 유효 비트
        - 현재 해당 페이지에 접근 가능한지 여부를 알려줌
        - 프레임 번호 다음으로 중요한 정보
        - 현재 페이지가 메모리에 적재되었는지 아니면 보조기억 장치에 있는지를 알려주는 비트
        - 만약 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 페이지 폴트 예외 발생
        - CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트 처리하는 과정과 유사
            - CPU 기존 작업 내역 백업
            - 페이지 폴트 처리 루틴 실행
            - 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 후 유효 비트를 1로 변경
            - 페이지 폴트를 처리했다면 해당 페이지의 CPU 접근 가능
    - 보호 비트
        - 페이지 보호 기능을 위해 존재하는 비트
        - 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타낼 수 있음
        - 코드 영역(읽기 전용 영역)에 쓰기를 시도하면 운영체제가 막아줌
        - 읽기 - r, 쓰기-w, 실행-x의 조합으로 읽기, 쓰기, 실행하기 권환의 조합을 나타낼 수 있음
    - 참조 비트
        - CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄
        - 적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1로 세팅되고, 적재 이후 한 번도 읽거나 쓴 적 없는 페이지는 0으로 유지
    - 수정 비트
        - 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려줌
        - 더티 비트
        - 1이면 변경된 적이 있는 페이지, 0이면 없는 페이지
        - 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재
            - CPU가 한 번도 접근하지 않았거나 읽기만 한 페이지의 경우 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지 내용은 아래 그림과 같이 서로 같은 값을 가짐
            - 한 번도 수정된 적이 없는 페이지가 스왑 아웃될 경우 아무런 추가 작업 없이 새로 적재된 페이지로 덮어쓰기
            - 하지만 CPU가 쓰기 작업을수행한 페이지 （수정 비트가 1인 페이지）의 경우 보조기억장치에 저장된 페이지의 내용과 메모리에 저장된 페이지의 내용은 서로 다른 값을 가짐
- 페이징이 제공하는 이점
    - 쓰기 시 복사
        - 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리킴
        - 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제
        - 프로세스 생성 시간을 줄이고 메모리 공간 절약 가능
- 계층적 페이징 (다단계 페이지 테이블 기법)
    - 프로세스의 크기가 커지면 자연히 프로세스 테이블의 크기도 커지기 때문에 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 메모리 낭비
    - 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법
    - 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
    - 프로세스의 페이지 테이블을 여러 개의 페이지로 자르고, 바깥쪽에 페이지 테이블을 하나 더 두어 잘린 페이지 테이블의 페이지들을 가리키게 하는 방식
    - 페이지 테이블들 중 몇 개는 보조기억장치에 있어도 무방하며, 추후 해당 페이지 테이블을 참조해야 할 때가 있으면 그때 메모리에 적재
        - 다만 CPU와 가장 가까이 위치한 페이지 테이블（Outer 페이지 테이블）은 항상 메모리에 유지
    - 논리 주소도 달라짐
        - 바깥 페이지 번호에 해당하는 항목은 CPU와 근접한 곳에 위치한（바깥에 위치한） 페이지 테이블 엔트리를 가리키고, 안쪽 페이지 번호는 첫 번째 페이지 테이블 바깥에 위치한 두 번째 페이지 테이블, 즉 페이지 테이블의 페이지 번호를 가리킴
        - 주소 변환
            - 바깥 페이지 번호를 통해 페이지 테이블의 페이지를 찾기
            - 페이지 테이블의 페이지를 통해 프레임 번호를 찾고 변위를 더함으로서 물리 주소 얻기
    - 페이지 테이블 계층이 늘어날수록 페이지 폴트가 발생할 경우 메모리 참조 횟수가 많아지므로 계층이 많다고 반드시 좋은 것이 아님

## 페이지 교체와 프레임 할당

### 요구 페이징 (demand paging)

- 프로세스를 메모리에 적재할 때, 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- 기본적인 양상
    1. CPU가 특정 페이지에 접근하는 명령어를 실행
    2. 해당 페이지가 현재 메모리에 있을 경우（유효 비트가 1일 경우） CPU는 페이지가 적재된 프레임에 접근
    3. 해당 페이지가 현재 메모리에 없을 경우（유효 비트가 0일 경우） 페이지 폴트가 발생
    4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
    5. 다시 1번을 수행
- 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있음
    - 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 후 페이지 폴트 발생 빈도가 떨어짐
    - 순수 요구 페이징 기법
- 요구 페이징 시스템이 안정적으로 작동하려면 페이지 교체와 프레임 할당을 해결해야함
- 쫓아낼 페이지를 결정하는 방법을 페이지 교체 알고리즘이라 함

### 페이지 교체 알고리즘

- 좋은 페이지 교체 알고리즘이란?
    - 페이지 폴트를 가장 적게 일으키는 알고리즘
        - 페이지 폴트가 일어나면 보조기억장치로부터 필요한 페이지를 가져와야하기 때문에 메모리에 적재된 페이지를 가져오는 것보다 느려지기 때문
        - "한 페이지 교체 알고리즘을 선택했더니 페이지 폴트가 자주 발생했다”는 말은“보조기 억장치로 내쫓을 페이지를 잘못 골랐다”는 뜻으로, 내보내면 안 되는 페이지를 보조기억장치로 내보냈다는 의미
    - 페이지 폴트 횟수
        - 페이지 참조열
            - CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열을 의미
            - 연속된 페이지를 생략하는 이유는 중복된 페이지를 참조하는 행위는 페이지 폴트를 발생시키지 않기 때문
- FIFO 페이지 교체 알고리즘
    - 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
    - 구현은 간단하지만 실행 초기에 적재된 페이지 속에는 프로그램 실행 초기에 잠깐 실행되다가 이후에 사용되지 않을 페이지도 있겠지만, 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있음
- 2차 기회 페이지 교체 알고리즘
    - 부작용을 어느 정도 개선한 FIFO 페이지 교체 알고리즘의 변형
    - 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
    - 차이가 있다면 만일 페이지의 참조 비트가 1 일 경우, 당장 내쫓지 않고 참조 비트를 0으로 만든 뒤 현재 시간을 적재 시간으로 설정
    - 메모리에 가장 오래 머무른 페이지의 참조 비트가 0일 경우 이 페이지는 가장 오래된 페이지이면서 동시에 사용되지 않은 페이지라고 볼 수 있음으로 보조기억장치로 내보냄
- 최적 페이지 교체 알고리즘
    - CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘
    - 보조기억장치로 내보내야 할 페이지는 앞으로 사용 빈도가 가장 낮은 페이지이므로, 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것이 가장 합리적
    - 가장 낮은 페이지 폴트율을 보장하는 알고리즘
    - 다만 실제 구현이 어려움
        - 앞으로 오랫동안 사용되지 않을 페이지를 예측하기 어려움
    - 운영체제에서 사용하기보다는, 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용
        - 최적 페이지 교체 알고리즘을 실행했을 때 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주하고, 최적 페이지 교체 알고리즘에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용
- LRU 페이지 교체 알고리즘
    - 가장 오랫동안 사용되지 ‘않을’ 페이지를 교체하는 알고리즘을 구현하기 어렵다면, 이를 조금 변형한 가장 오랫동안 사용되지 ‘않은’ 페이지를 교체하는 알고리즘은 구현이 가능

### 스래싱과 프레임 할당

- 프로세스가 사용할 수 있는 프레임 수가 적어도 페이지 폴트는 자주 발생
    - 더 근본적인 이유
    - 프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없음
    - 실행의 맥이 탁 탁 끊기고, 결과적으로 CPU의 이용률도 떨어짐
    - 이처럼 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 스래싱(thrashing)이라 함
- 멀티프로그래밍의 정도
    - 메모리에서 동시 실행되는 프로세스의 수
    - 멀티프로그래밍의 정도가 높으면 현재 메모리에서 많은 프로세스가 동시에 실행 중이고, 낮다면 현재 메모리에서 적은 프로세스가 동시에 실행 중
    - 동시에 실행되는 프로세스의 수（멀티프로그래밍의 정도）를 늘린다고 해서 CPU 이용률이 그에 비례해서 증가하는 것이 아님
        - CPU 이용률이 높아지지만 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번하게 발생 → CPU 이욜률이 떨어져 전체적인 성능이 저해
    - 스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
    - 운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 함
- 프레임 할당 방식
    - 균등 할당
        - 세 개의 프로세스에 총 300개의 프레임을 할당할 수 있다면 각 프로세스에 100개씩의 프레임을 할당하는 방식
        - 실행되는 프로세스들의 크기는 각기 다른데 천편일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적
    - 비례 할당
        - 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식
        - 프로세스의 크기가 클지라도 막상 실행해보니 많은 프레임을 필요로 하지 않는 경우도 존재
        - 결국 실행해봐야 암
    - 균등 할당과 비례 할당 방식은 프로세스 실행 과정을 고려하지 않고 프로세스의 크기와 물리 메모리 크기만을 고려한 방식으로 정적 할당 방식
- 프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식
    - 작업 집합 모델
        - 프로세스가 일정 기간 동안 참조한 페이지 집합을 기억하여 빈번한 페이지 교체를 방지
            - 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합을 작업 집합
            - 참조 지역성의 원리?
        - CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 페이지 교체는
        빈번하게 발생하지 않음
    - 페이지 폴트 빈도
        - 두 가지 가정에서 생겨난 아이디어
            - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있음
            - 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있음
            - 페이지 폴트율 상한선과 하한선을 정해 만일 페이지 폴트율이 상한선보다 더 높아지면 그 프로세스는 너무 적은 프레임을 갖고 있다고 보고 이 경우 프레임을 더 할당, 반대로 페이지 폴트율이 하한선보다 더 낮아지면 그 프로세스는 너무 많은 프레임을 갖고 있다고 보고 다른 프로세스에 할당하기 위해 프레임 회수
    - 프로세스의 실행을 보고 할당할 프레임 수를 결정한다는 점에서 동적 할당 방식