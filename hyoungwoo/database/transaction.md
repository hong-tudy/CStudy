- 정의
    - 트랜잭션이란 데이터베이스에서 데이터를 안전하게 처리하기 위해 하나 이상의 작업을 하나의 작업 단위로 묶은 것
    - 한 번에 하나의 논리적 기능을 수행하는 작업의 집합으로, 여러 개의 개별 작업들을 포함할 수 있지만, 이러한 작업들은 모두 함께 성공적으로 완료되거나, 아니면 전혀 실행되지 않아야 함
    - 트랜잭션은 주로 데이터베이스 시스템에서 사용되며 데이터의 일관성과 무결성을 보장
    - 트랜잭션의 주요 속성은 ACID(원자성, 일관성, 격리성, 지속성)
- **ACID 속성**
    - 원자성(Atomicity)
        - 트랜잭션이 데이터베이스에 모든 변경 사항을 성공적으로 적용하거나, 아무것도 적용하지 않도록 보장
        - 트랜잭션 내의 모든 연산이 완전히 성공하거나, 하나라도 실패할 경우 전체 트랜잭션을 취소(롤백)
    - 일관성(Consistency)
        - 트랜잭션이 성공적으로 완료되면, 데이터베이스가 일관된 상태를 유지한다는 것을 의미
        - 모든 데이터 규칙과 제약조건을 만족해야 하며, 트랜잭션 전후 모두 데이터의 일관성이 보장
    - 격리성(Isolation)
        - 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않도록 격리
        - 이는 동시성 제어를 통해 달성되며, 더티 리드(dirty reads), 낮실읽기(non-repeatable reads), 팬텀 리드(phantom reads) 같은 문제를 방지하는 것을 목표
    - 지속성(Durability)
        - 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템 오류가 발생하더라도 영구적으로 데이터베이스에 반영
        - 시스템이 실패해도, 완료된 트랜잭션의 결과는 사라지지 않고 유지
- 스프링에서 트랜잭션을 관리하는 방법
    - 선언적 트랜잭션 관리와 프로그래매틱 트랜잭션 관리가 존재, 대부분의 개발자들은 선언적 트랜잭션 관리 방법을 선호, 스프링의 관점 지향 프로그래밍(AOP) 기능과 트랜잭션 어노테이션을 사용하여 간단하고 세련된 방법으로 트랜잭션을 관리
    - 선언적 트랜잭션 관리
        - 선언적 트랜잭션 관리는 주로 **`@Transactional`** 어노테이션을 사용하여 관리
        - 이 어노테이션을 클래스나 메소드에 적용함으로써 해당 범위의 실행을 트랜잭션으로 감쌈
        - 스프링이 자동으로 해당 트랜잭션의 시작, 커밋, 롤백 등을 관리
        - 전파 옵션 (`Propagation`): 트랜잭션의 전파 범위와 새 트랜잭션이 기존 트랜잭션에 어떤 식으로 포함될지 결정
            - **`REQUIRED`, `REQUIRES_NEW`, `SUPPORTS`**
        - 격리 수준 (`Isolation`): 동시에 여러 트랜잭션이 진행될 때, 데이터 일관성을 유지하기 위한 트랜잭션의 격리 수준을 설정
            - **`READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`**
    - 프로그래매틱 트랜잭션 관리
        - 프로그래매틱 트랜잭션 관리는 트랜잭션을 직접 코드로 관리하는 방법
        - **`TransactionTemplate`** 또는 트랜잭션 매니저 API를 직접 사용하여 트랜잭션의 시작, 커밋, 롤백을 직접 제어
        - 이 방법은 선언적 관리보다 유연성은 높지만, 코드 복잡도가 올라가는 단점
- 대부분의 경우**, `@Transactional`** 어노테이션을 사용하는 선언적 트랜잭션 관리 방법이 간단하고 효율적인 해결책을 제공
- 격리성과 관련되어 발생할 수 있는 문제점
    - Dirty Read
        - 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것
        - 트랜잭션이 완료되지 않은 상황에서 데이터 접근을 허용할 경우 발생할 수 있는 데이터 불일치 현상
        - 예시
            
            트랜잭션 A가 어떤 값을 "아마찌"에서 "newwisdom"로 변경 후, 커밋하지 않은 상황에서
            트랜잭션 B가 같은 값을 읽을 경우 트랜잭션 B는 "newwisdom"를 조회하게 된다.
            
            만약 B가 "newwisdom"을 조회한 후 A가 롤백이 될 경우 트랜잭션 B는 잘못된 값을 읽게 된다.
            
    - None-Repeatable Read
        - 한 트랜잭션에서 같은 쿼리 두번 실행에 대한 데이터 불일치 현상
        - Dirty Read보다 발생률이 적고 일반적인 웹 어플리케이션에서는 큰 문제가 되지는 않지만, 금전적인 처리가 얽혀있다면 큰 문제가 될 수 있음
        - 예시
            - 트랜잭션 A가 "아마찌"를 읽었고, 이후 A가 같은 쿼리를 또 실행할 예정인데, 그 사이에 트랜잭션 B가 "아마찌"를 "newwisdom"으로 수정하고 COMMIT하면 A가 한 트랜잭션 내에서 같은 쿼리를 두번 날리는 사이에 두 쿼리의 결과가 다르게 되어 버린다.
            - 입금/출금 처리가 계속 진행되는 트랜잭션들이 있고, 입금 총합을 보여주는 트랜잭션이 있는 여러개의 트랜잭션이 있는 상황에서, 총합을 계산하는 select 쿼리가 실행될 때마다 다른 결과값을 가져온다.
    - Phantom Read
        - 한 트랜잭션에서 일정 범위의 레코드를 두 번 이상 읽을 때 발생하는 데이터 불일치
        - 첫번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상
        - 예시
            
            트랜잭션 A가 어떤 조건절을 사용해 특정 범위의 값들을 읽었다.
            
            이 후 A가 같은 쿼리를 실행할 예정인데, 그 사이에 트랜잭션 B 가 같은 테이블에 값을 추가해버리면 A가 같은 쿼리 두 번을 날리는 사이에 두 쿼리의 결과가 다르게 된다.
            
- 선언적 트랜잭션 속성
    - **isolation**
        - DEFAULT
            - 기본설정
            - DB의 격리 Level을 따름
            - Mysql InnoDB 의 기본 설정은 REPEATABLE READ
        - READ_UNCOMMITED (level0):
            - COMMIT 되지 않은(아직 트랜잭션 처리 중인) 데이터에 대한 읽기를 허용
            - **Dirty Read, Non-Repeatable Read, Phantom Read 발생**
        - READ_COMMITTED (level 1):
            - 트랜잭션이 COMMIT된 데이터에 대해서만 읽기를 허용
            - **위에서 발생한 Dirty Read 문제점을 해결할 수 있음**
            - **Non-Repeatable Read, Phantom Read 발생**
        - REPEATABLE_READ (level 2):
            - 트랜잭션이 완료될 때 까지 SELECT 문이 조회하는 데이터들에 대해선 LOCK이 걸려 다른 사용자는 해당 영역의 데이터에 대한 수정이 불가능
            - 선행 트랜잭션이 읽은 데이터는 트랜잭션이 종료될 때까지 후행 트랜잭션이 갱신하거나 삭제가 불가능해, 한 트랜잭션에서 같은 쿼리 두번 실행에 대한 데이터의 일관성을 보장
            - **위에서 발생하는 Non-Repeatable Read 문제점을 해결할 수 있음**
            - **Phantom Read 발생**
                - 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 해당 격리 수준에서도 이미 **Phantom Read**가 발생하지 않음
                - 갭락과 넥스트 키 락
                    
                    ### 갭 락(Gap Locks)
                    
                    갭 락은 레코드 간의 간격에 락을 거는 방식입니다. 즉, 레코드 자체가 아니라 레코드 간의 '갭'에 락을 걸어 다른 트랜잭션이 해당 갭에 새로운 레코드를 삽입하는 것을 방지합니다. 이를 통해 팬텀 리드를 방지할 수 있습니다.
                    
                    ### 넥스트 키 락(Next-Key Locks)
                    
                    넥스트 키 락은 갭 락과 레코드 락(레코드 자체에 거는 락)을 합친 것으로, 레코드와 그 레코드의 앞 갭 모두에 락을 거는 방식입니다. 이 방식으로 인해 InnoDB에서는 더욱 엄밀하게 범위 쿼리를 처리하여 팬텀 리드를 방지할 수 있습니다. 특히, 'REPEATABLE READ'(반복 가능한 읽기) 격리 수준에서 넥스트 키 락을 사용하는 것이 기본 값으로 설정되어 있어, 이 격리 수준에서 팬텀 리드가 발생하지 않습니다.
                    
        - SERIALIZABLE (level 3):
            - 동시에 같은 테이블의 정보를 접근할 수 없음
            - 트랜잭션을 순차적으로 수행하는 것과 다를 바 없어 성능이 매우 저하됨
            - **Phantom Read 문제점을 해결할 수 있음**
    - propagation (전파 옵션)
        - 트랜잭션 동작 도중 다른 트랜잭션을 호출하는 상황에 선택할 수 있는 옵션
        - **REQUIRED**
            - 기본 설정
            - 부모 트랜잭션 내에서 실행하며, 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성
        - **readOnly**
            - 트랜잭션을 읽기 전용으로 설정 가능 (SELECT)
            - 성능 최적화, 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용
            - 읽기 전용 트랜잭션이 시작된 이후 CUD 같은 쓰기 작업이 진행되면 예외가 발생
        - **REQUIRED_NEW**
            - 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션을 생성
        - **SUPPORTS**
            - 이미 시작된 트랜잭션이 있으면 참여, 그렇지 않으면 트랜잭션 없이 진행
        - **MANDATORY**
            - REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여
            - 반면 트랜잭션이 시작된 것이 없으면 예외를 발생시킴
            - 혼자서는 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용
        - **NOT_SUPPORTED**
            - 트랜잭션을 사용하지 않게함
            - 이미 진행중인 트랜잭션이 있으면 보류하고 메서드 실행
        - **NEVER**
            - 트랜잭션을 사용하지 않도록 강제
            - 이미 진행중인 트랜잭션이 존재한다면 예외 발생
        - **NESTED**
            - 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작
            - 중첩 트랜잭션이란 트랜잭션 안에 다시 트랜잭션을 만드는 것을 의미
            - 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않음
            - 부모 트랜잭션이 없을 경우 REQUIRED와 동일히 작동
    - **트랜잭션 롤백 예외 - (rollback-for, rollbackFor, rollbackForClassName)**
        - 선언적 트랜잭션에서는 런타임 예외가 발생하면 ROLLBACK
        - 예외가 발생하지 않거나, Checked Exception이 발생하면 COMMIT
        - 스프링에서는 Data Access 기술의 예외는 런타임 예외로 전환되어 런타임 예외만 롤백 대상으로 삼음
        - 이 기본 동작 방식을 바꿀 수 있는 옵션
    - **timeout**
        - 지정 시간 내에 해당 메서드 수행이 완료되지 않은 결루 ROLLBACK
        - 기본설정은 -1로 No Timeout