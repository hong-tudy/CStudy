### DB Index

- 관계형 데이터베이스에서 검색 속도를 높이기 위한 기술
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
    - Table의 **Column을 색인화** 함 (따로 파일로 저장)
    - 해당 Table의 Record를 Full scan 하지 않음
    - 색인화 된 (B+ Tree 구조로) Index 파일 검색으로 검색 속도 향상
- 인덱스를 사용하지 않은 컬럼을 조회해야 하는 상황이면, 전체를 탐색하는 Full Scan을 수행해야 하는데 Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어짐
- 과정
    - Table을 생성하면, MYD, MYI, FRM 3개의 파일이 생성
        - FRM : 테이블 구조가 저장되어 있는 파일
        - MYD : 실제 데이터가 있는 파일
        - MYI : Index 정보가 들어가 있는 파일
    - Index를 사용하지 않는 경우, MYI 파일은 비어져 있음. 그러나, 인덱싱하는 경우 MYI 파일이 생성
    - 이후 사용자가 select 쿼리로 index를 사용하는 column을 탐색 시, MYI 파일의 내용을 검색
- 단점
    - index 생성 시, .mdb 파일 크기가 증가
        - 인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요
    - 한 페이지를 동시에 수정할 수 있는 병행성 줄어듬
    - 인덱스된 field에서 Data를 업데이트 하거나, Record를 추가 또는 삭제할 때, 성능이 떨어짐
    - 데이터 변경 작업이 자주 일어나는 경우, index를 재작성해야 하므로, 성능에 영향을 미침

### 인덱스 관리

- DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있음
- 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각의 연산을 추가적으로 해주어야 하므로 오버헤드 발생
    - INSERT
        - 기존 Block에 여유가 없을 때, 새로운 데이터가 입력됨
        - 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행(많은 양의 Redo가 기록되고, 유발)
        - Index split 작업 동안, 해당 Block의 key 값에 대해서 DML이 블로킹 됨 → 대기 이벤트 발생
    - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
        - Table과 Index 상황 비교
            - Table에서 Data가 delete 되는 경우
                - Data가 지워지고 다른 Data가 그 공간을 사용
            - Index에서 Data가 delete되는 경우
                - Data가 지워지지 않고, 사용 안됨 표시만 해둠
            - **Table의 Data 수와 Index의 Data 수가 다를 수 있음**
    - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함
        - Table에서 update가 발생하면 Index는 Update 할 수 없음
        - Index에서는 **Delete가 발생한 후**, **새로운 작업의 Insert 작업** / 2배의 작업이 소요되어, 힘듬
- CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생

### 상황

- 사용하면 좋은 경우
    - Where 절에서 자주 사용되는 Column
    - 외래키가 사용되는 Column
    - Join에 자주 사용되는 Column
- Index 사용을 피해야하는 경우
    - Data 중복도가 높은 Column
    - DML이 자주 일어나는 Column

### 인덱스의 자료구조

- 해시 테이블
    - (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용
    - Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조
    
    ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/RpMoO/btqKMzdg9TX/XYkGt2kqE0hr9rqhHx3o3K/img.png)
    
    - 시간복잡도는 O(1)이며 매우 빠른 검색을 지원
    - DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문
    - 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않음
- B+Tree
    - DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
    - 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성
        - 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖음
        - 리프노드들은 LinkedList로 연결되어 있음
        - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 됨
    - BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화
        - Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/d78iJ0/btqKRYbLdM9/nIvz1M4gffMl4YHS77JSfK/img.png)

### 인덱스 설계

- 인덱스 선택 및 순서에 따라 인덱스를 이용한 스캔을 하므로 설계할 때부터 순서를 유의해서 만들어야 함
    - 조건절에 항상 또는 자주 사용되는 컬럼 선택
    - ‘=’ 조건으로 자주 조회되는 컬럼을 앞쪽 순서에 위치
    - 분포도가 좋은 컬럼 선정 (분포도 15% 이내)

| 기준 | 설명 | 적정도 |
| --- | --- | --- |
| 카디널리티 (Cardinality) | 한 컬럼이 갖고 있는 값의 중복 정도를 나타냅니다. 값의 중복이 적을수록 좋습니다. | 높은수록 적합 |
| 선택도 (Selectivity) | 특정 값 또는 평균값의 비율이 총 row 수에 대한 비율을 나타냅니다. | 낮을수록 적합 |
| 활용도 (Usage) | 해당 컬럼이 실제 작업에서 얼마나 자주 사용되는지를 나타냅니다. | 높을수록 적합 |
| 중복도 (Redundancy) | 중복 인덱스 여부를 나타냅니다. 중복 인덱스가 없을수록 좋습니다. | 없을수록 적합 |
- 절차
    - 접근경로 수집
        - 반복 수행되는 접근 경로
            - Join 컬럼
        - 분포도가 양호한 컬럼
        - 조회 조건에 사용되는 컬럼
        - 자주 결합되어 사용되는 컬럼
        - 데이터 정렬 순서와 그룹핑 컬럼
        - 일련 번호를 부여한 컬럼
        - 통계 자료 추출 조건
        - 조회 조건이나 조인 조건 연산자
    - 분포도에 의한 후보 컬럼 선정
        - 분포도 10~15% 선정 추천
            - 분포도(%) = 데이터별 평균 row 수 / 테이블의 총 row 수 * 100
    - 컬럼 조합 및 순서 결정
        - 항상 사용되는 컬럼을 선두 컬럼 선정
        - 등치(=)조건으로 사용되는 컬럼을 선행 컬럼으로 선정
        - Order By, Group By 순서 적용