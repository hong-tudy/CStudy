### 개념

- DB란?
    - 데이터의 저장소
- **DBMS**
    - 데이터베이스란 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
    - 계층형, 망형, 관계형 DBMS 중 대부분의 DBMS가 테이블로 구성된 관계형 DBMS(RDMBS)형태로 사용됨
- 키 (Key)
    - 기본 키
        - 테이블에서 각 행을 고유하게 식별할 수 있는 키
        - NULL 값을 가질 수 없으며, 테이블에 하나만 존재할 수 있음
    - 후보 키
        - 유일성
            - Key로 하나의 Tuple을 유일하게 식별할 수 있음
            - Tuple
                - 릴레이션을 구성하는 각각의 행, 속성의 모임으로 구성
                - 파일 구조에서는 레코드와 같은 개념
        - 최소성
            - 꼭 필요한 속성으로만 구성
        - 기본 키로 사용할 수 있는 속성들의 집합
        - 하나의 테이블에서 여러 개의 후보 키가 존재할 수 있으며, 이 중 하나가 기본 키로 선택
    - 대체 키
        - 후보 키 중에서 기본 키로 선택되지 않은 나머지 키
    - 외래 키
        - 한 테이블의 키가 다른 테이블의 기본 키를 참조하는 경우의 키
        - 테이블 간의 관계를 설정하는 데 사용
    - 슈퍼 키
        - 테이블에서 각 행을 고유하게 식별할 수 있는 하나 이상의 속성들
        - 슈퍼 키는 기본 키를 포함하며, 후보 키보다 넓은 개념
    - 복합 키
        - 두 개 이상의 속성으로 이루어진 키
        - 여러 속성의 결합으로 테이블의 각 행을 고유하게 식별
- Join
    - 데이터베이스에서 두 개 이상의 테이블을 결합하여 하나의 결과 집합을 만드는 SQL 연산
    - 조인의 종류
        
        ![](https://images.velog.io/images/chayezo/post/5403f167-f07f-4dae-87f7-1d123c2f758c/99219C345BE91A7E32.png)
        
        - INNER JOIN
            - 두 테이블 간의 공통된 키를 기반으로 결합하여, 두 테이블 모두에서 매칭되는 레코드만 반환함
        - LEFT JOIN (또는 LEFT OUTER JOIN)
            - 왼쪽 테이블의 모든 레코드와 오른쪽 테이블의 매칭되는 레코드를 반환하며, 오른쪽 테이블에 매칭되는 레코드가 없으면 NULL 반환
        - RIGHT JOIN (또는 RIGHT OUTER JOIN)
            - 오른쪽 테이블의 모든 레코드와 왼쪽 테이블의 매칭되는 레코드를 반환하며, 왼쪽 테이블에 매칭되지 않는 레코드는 NULL 반환
        - FULL OUTER JOIN
            - 두 테이블에서 매칭되는 레코드를 모두 반환하며, 어느 한쪽에 매칭되지 않는 레코드도 NULL 값과 함께 반환함
        - CROSS JOIN
            - 두 테이블의 모든 가능한 조합을 반환함
        - SELF JOIN
            - 동일한 테이블을 두 번 참조하여 테이블 내의 데이터를 비교하거나 결합함
        - 조인 성능 최적화
            - 조인을 수행할 때, 조인 조건에 사용되는 열에 인덱스를 설정하면 성능이 크게 향상
            - 경우에 따라 서브쿼리보다 조인을 사용하는 것이 성능에 더 유리할 수 있음
                - 다수의 데이터를 결합할 때는 조인이 유리
            - 3개 이상의 테이블을 조인하는 경우, 조인의 순서와 방식이 중요
            - Self Join의 활용
                - 자기 자신과 조인하여 상위-하위 관계를 표현
- 이상
    - 데이터베이스에서 데이터의 불일치, 중복, 무결성 문제 등을 초래하는 상황
        - 주로 정규화되지 않은 데이터베이스에서 발생
    - 삽입 이상
        - 새로운 데이터를 삽입할 때 불필요한 데이터도 함께 삽입해야 하는 문제
        - 예시
            - 기본키가 {Student ID, Course ID} 인 경우 -> Course를 수강하지 않은 학생은 Course ID가 없는 현상이 발생함. 결국 Course ID를 Null로 할 수밖에 없는데, 기본키는 Null이 될 수 없으므로, Table에 추가될 수 없음.
    - 갱신 이상
        - 데이터를 갱신할 때 동일한 데이터가 여러 곳에 중복되어 있어, 일부만 갱신할 경우 불일치가 발생하는 문제
        - 예시
            - 모든 Department를 "음악"으로 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악 못함
    - 삭제 이상
        - 데이터를 삭제할 때, 원치 않는 데이터도 함께 삭제되는 문제
        - 예시
            - 만약 어떤 학생이 수강을 철회하는 경우, {Student ID, Course ID, Department, Course ID, Grade}의 정보 중, Student ID, Department 와 같은 학생에 대한 정보도 함께 삭제됨.

### SQL vs NoSQL

- SQL과 NoSQL 데이터베이스는 데이터를 저장하고 검색하는 방법에 중요한 차이를 가지고 있으며, 각각 다른 사용 사례와 장단점이 있음
- SQL(관계형 데이터베이스, Stands for Structured Query)
    - 정의
        - SQL은 데이터를 쿼리하고 관리하는 데 사용되는 도메인 고유의 언어
        - 사용자가 관계형 데이터베이스에서 레코드를 쿼리, 삽입, 삭제 및 업데이트할 수 있도록 하는 방식으로 작동
        - SQL을 사용하면 트랜잭션과 저장 함수 또는 뷰와 같은 내장 프로시저를 사용하여 복잡한 로직을 적용 가능
    - 테이블 기반 구조를 사용하여 데이터를 관리하며, 데이터는 열(column)과 행(row)으로 구성
    - 구조화된 데이터 모델: 데이터는 엄격한 데이터 스키마(구조)을 따라야 하며, 테이블 형태로 저장
    - 무결성과 일관성: 데이터 무결성 규칙을 사용해 데이터의 정확성과 일관성을 보장
    - 관계: 테이블 사이의 관계를 정의하여 중복을 최소화하고 데이터의 효율성을 높임
    - 트랜잭션 지원: 복잡한 조작을 수행하는 동안 데이터베이스의 일관성을 보장
    - Ex) MySQL, PostgreSQL, Oracle Database, Microsoft SQL Server
- NoSQL (비관계형 데이터베이스)
    - 정의
        - NoSQL은 Not Only SQL의 약자로, 관계형 데이터베이스가 제공하는 엄격한 테이블 구조를 따르지 않고, 다양한 데이터 저장 모델(문서, 키-값, 그래프 등)을 이용하는 데이터베이스 시스템을 총칭
        - NoSQL 시스템은 기존의 관계형 데이터베이스보다 유연하게 설계되어 사용량이나 부하 변화에 따라 쉽게 확장 또는 축소
        - 따라서 애플리케이션에 사용하기에 이상적
    - 유연한 데이터 모델: 고정된 스키마가 없어 다양한 형태의 데이터를 유연하게 저장
    - 확장성: 데이터베이스를 수평적으로 쉽게 확장할 수 있어, 대량의 데이터를 처리하는데 유리(샤딩), SQL은 수직적 확장
        - 수직적 확장: CPU, RAM 또는 SSD 용량을 추가하여 단일 서버의 부하를 늘릴 수 있음
        - 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)
        - 샤딩은 NoSQL 데이터베이스에 더 많은 서버를 추가 수평 확장은 수직 확장보다 전체 용량이 더 큼
    - 고성능: 간단한 쿼리 모델과 분산 시스템 설계로 빠른 읽기 및 쓰기 성능을 제공, 개발자가 기존 관계형 데이터베이스의 오버헤드 없이 데이터를 빠르고 쉽게 저장하고 액세스
    - 다양성: 문서 지향, 키-값 저장소, 와이드 컬럼 저장소, 그래프 데이터베이스 등 다양한 데이터 모델을 제공
    - Ex) MongoDB (문서 지향 데이터베이스), Redis (키-값 저장소), Cassandra (와이드 컬럼 스토어), Neo4j (그래프 데이터베이스)
- 복잡한 조인과 트랜잭션, 데이터 무결성이 중요한 경우 SQL이 더 적합할 수 있으며, 유연한 구조, 대규모 데이터, 빠른 처리 속도가 필요한 경우 NoSQL이 더 적합

### 정규화

### 무결성

- 데이터가 Lifecycle 동안 얼마나 완전하고 일관되며 정확한지

# 데이터베이스 스키마란?

- 특정 데이터베이스 구조 또는 구성에 대한 형식적인 설명
- 관계형 데이터베이스, 즉 테이블에 정보를 구성하고 SQL 쿼리 언어를 사용하는 데이터베이스와 관련하여 가장 일반적으로 사용

## 물리적 데이터베이스 스키마

- 데이터가 스토리지 시스템에 물리적으로 저장되는 방식과 사용되는 스토리지 형태(파일, 키값 쌍, 인덱스)등을 설명

## 논리적 데이터베이스 스키마

- 데이터에 적용되는 논리적 제약 조건을 설명하고 필드, 테이블, 관계, 보기, 무결성 제약 조건 등을 설명

## 설계가 중요한 이유

- 비효율적으로 구성된 데이터베이스는 리소스를 소모하고 혼란을 야기, 유지 및 관리가 어려움
    - 데이터 중복 감소 또는 제거
    - 데이터 불일치 및 부정확성 방지
    - 데이터의 정확성과 무결성 보장
    - 신속한 데이터 조회, 검색 및 분석 지원
    - 기밀 데이터를 안전하게 유지하면서도 필요한 사용자가 엑세스할 수 있도록 지원
    

## 정규화 절차

- 어떤 중복인지를 파악하고, 중복이 되는 대상을 형태별로 구분한 것을 정규형이라고 함
- 정규형에 따라 데이터 중복을 없애기 위해 수행하는 중복 제거 방법을 정규화라고 함
- 정규화는 1차 정규화부터 5차 정규화까지 5가지가 있으면 정규형도 5차형까지 있고 보통 정규화는 3차까지만 실행함

## 함수적 종속성

- 정규화는 함수적 종속성을 기초로 해서 실행
- 함수적 종속성이란 A → B와 같은 관계 표현에 의해 ‘A이면 반드시 B이다’와 같은 종속적인 관계가 성립하는 것을 말함
- A가 변경되면 B도 반드시 변경되기 때문에 B는 A의 값 변경에 완전히 종속
    - 주문 정보의 회원 ID가 변경되면 주문한 회원과 관련된 모든 정보는 자동으로 변경
- 중복 데이터가 발생하는 테이블을 “함수적 종속성”을 가지도록 기본 키를 사용하여 2개 이상의 테이블로 분해를 하는 과정을 제 1정규화라고 함
    - 제1 정규화의 함수적 종속성은 다른 정규화와 명확하게 구분하기 위해 “완전 함수 종속”이라고 함
- 2개 이상의 컬럼을 묶어서 기본키(복합키)의 역할을 하는 경우 묶인 복합키 중 1개의 키에만 종속된 컬럼이 있으면 부분 함수 종속성이 발생했다고 하고, 테이블을 분리해서 부분 함수 종속성을 해결해야 하는데 이를 제2 정규화라고 함
- 기본키(복합키 포함)를 제외한 일반 컬럼들 사이에 종속성이 발생하면 마찬가지로 이 컬럼들도 별도의 테이블로 분리하여야 하는데 이렇게 일반 컬럼들 사이에 종속성이 발생한 것을 이행 함수 종속성이 발생했다고 하고 이 이행함수 종속성 문제를 해소하는 것을 제3 정규화라고 함
- 정규화의 단계는 1 → 2 → 3정규화 순서로 진행해야 함
- 함수적 종속성 → 부분 함수 종속성 → 이행 함수 종속성
- 한 개의 데이터는 한 곳에만 있어야 한다

### 제1 정규화

- 테이블 안의 속성 값에는 중복된 데이터가 없어야 함
- 컬럼 방향의 정규화와 행 방향의 정규화 2개로 나눌 수 있음
- 2단계는 행 단위로 중복되는 데이터들을 2개 이상의 테이블로 나누고 기본키를 사용해 서로 연결을 해주는 단계
- 대부분의 정규화 과정은 제1 정규형만 만족해도 충분히 중복 데이터 없는 데이터 구조를 만들 수 있음

![8.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/85131cd9-96c2-42f7-9b90-ada271862e1d/a31cf0ce-c35a-4d50-bbb5-b8384161a507/8.jpg)

### 제2 정규화

- 기본키가 복합키로 구성된 경우, 모든 속성은 복합키에만 의존적이여야 함
- 복합키에 의존적이지 않고 복합키를 구성하는 하나의 컬럼에만 의존적인 컬럼이 있으면, 이 속성은 별도의 테이블로 분리하거나, 복합키에 의존적이도록 변경해야함
    
    ![4_1.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/85131cd9-96c2-42f7-9b90-ada271862e1d/09b06e74-e317-405b-bbd2-e7f48647d93c/4_1.jpg)
    

### 제3 정규화

- 기본키 이외의 일반 컬럼들끼리 의존성이 있는지 확인해서 분리하는 것
- 테이블의 속성들이 기본키에 의존적이지 않고, 일반 컬럼들끼리만 의존적인 관계가 생성될 경우, 3차 정규화 대상
    
    ![12-3.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/85131cd9-96c2-42f7-9b90-ada271862e1d/9bb6712d-f771-49e9-b85d-4af23c20bfff/12-3.jpg)
    

### 정규화의 단점 및 반정규화

- 정규화는 데이터의 무결성을 보장하는 가장 중요한 기본 원칙이지만, 절대적으로 중복이 없도록 100% 완벽한 정규화를 유지해야만 하는 것은 아님
- 정규화가 세밀하게 될수록 테이블 개수가 많아지고 더 많은 테이블은 원하는 쿼리 결과를 얻기 위해 더 많은 테이블을 조인해야함
    - 쿼리문이 복잡해지고 테이블의 관계 파악이 어려워짐
- 테이블 확장에 많은 제약이 생기고 테이블 삭제도 어려움
- 경우에 따라 정규화에 충실할수록 테이블 복잡도가 증가하면서 조인 과정이 복잡해지고 쿼리 결과를 얻는데 더 오랜 시간이 걸리는 역효과 발생
    - 무결성 원칙을 일부 훼손하지만 쿼리 편의성과 쿼리 속도를 올리기 위해 일부 중복 데이터를 허용하는 반정규화

### 반정규화

- 가장 큰 목적은 쿼리 성능의 향상
- 일반적으로 다음과 같은 경우에 수행
    - 조회가 빈번한 원격 테이블, 또는 타 데이터베이스의 테이블 접근 속도를 높이기 위해 중복 데이터를 담은 추가 테이블을 로컬 데이터베이스에 생성
    - 요약, 집계 데이터 자주 얻어야 하는 경우, 계산 결과를 미리 담아놓는 테이블, 컬럼을 추가하거나, 요약 집계에 필요한 컬럼들을 모아서 별도의 테이블을 생성
    - 빈번하게 자주 조회하는 컬럼 데이터들만을 모아놓은 테이블을 추가해서 많은 테이블 조인이 발생하지 않도록 함
    - 매번 조인이 발생하는 정규화된 테이블을 하나로 병합해 불필요한 테이블 조인을 단순화
    - 중복 컬럼이나 원래의 컬럼 데이터를 가공한 컬럼을 추가해서 컬럼 가공 시간과 연산이 필요한 함수 사용을 줄임
    
- 데이터의 무결성을 유지하면서 데이터를 가져오는 최적화 방법으로는 인덱스 클러스터링과 파티셔닝 같은 방법이 있음
    - 쿼리 튜닝: 쿼리 실행 계획을 최적화하여 성능을 향샹시키는 작업
    - 인덱스 최적화: 인덱스의 설계와 관리를 통해 쿼리 검색 속도를 향상
    - 테이블 파티셔닝: 대용량 테이블을 분할하여 관리하고 검색 성능을 향샹
    - 캐시 최적화: 데이터의 임시 저장 공간인 캐시를 최적화하여 데이터베이스 접근 속도를 향상

### BSNF 정규화(**Boyce-Codd Normal Form)**

- 3NF(제3정규형)를 더 엄격하게 만든 형태로, "모든 결정자가 후보 키여야 한다"는 조건을 충족
- 데이터 중복을 최소화하고, 데이터 무결성을 유지하기 위해 설계된 기법
- 어떤 데이터베이스 테이블이 BSNF에 있다는 것은 그 테이블이 제3정규형에 있으면서, 모든 속성들이 완전 함수적 종속을 만족한다는 것을 의미
- **"완전 함수적 종속"이란, 테이블의 모든 속성이 그 테이블의 후보 키에만 함수적으로 종속되어 있어야 함을 의미**
- **데이터베이스 설계에서 중복을 제거하고, 무결성을 향상시키며, 수정, 삽입, 삭제 이상 현상을 줄이기 위해 중요**
- **하지만, 보다 복잡한 쿼리와 테이블 조인의 증가라는 trade-off가 발생할 수 있으므로, 실제 응용 프로그램의 요구 사항과 성능 목표를 고려하여 적절한 정규형 수준을 선택해야 함**

제4 정규형 : 다치 종속 제거

제5 정규형: 조인 종속 제거