## 동기화의 의미

**동기화** : 실행되는 프로세스들의 실행 순서와 자원의 일관성을 보장하기 위한 것

협력적으로 실행되는 프로세스들은 아무렇게나 마구 동시에 실행되면 안된다

**프로세스 동기**화 : 프로세스들 사이의 수행 시기를 맞춘다

**실행 순서 제어** : 프로세스를 올바른 순서대로 실행하기

ex).txt파일에 쓰기 → 읽기

**상호 배제(mutual exclusion)** : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기. 즉 한 프로세스가 해당 자원을 모두 사용한 후에 다른 프로세스가 접근할 수 있도록 한다

ex) 계좌 잔액을 두 프로세스가 동시에 접근 X

## 생산자와 소비자 문제

producer and consumer problem

동시에 접근해서는 안 되는 자원에 동시에 접근했을 때 발생하는 문제

생산자가 소비자의 작업이 끝나기도 전에 총합을 수정했기 때문에 발생하는 문제

계좌 잔액 문제와 같은 문제다

```jsx
총합 = 10
생산자 0 {
	버퍼에 데이터 삽입
	‘총합’ 변수 1 증가
소비자 0 {
	버퍼에서 데이터 빼내기
	‘총합’ 변수 1 감소
}

//생산자와 소비자를 각각 10,000번씩 실행했을 때 총합이 일정하게 유지되지 않을 수도 있다
```

### 공유 자원과 임계 구역

**공유 자원 :** 동시에 접근해서는 안 되는 자원. 두 개 이상의 프로세를 동시에 실행하면 문제가 발생하는 자원

ex ) 잔액, 총합, 지역변수, 파일, 입출력 장치, 보조기억장치 등

**임계 구역(Critical Section)** : 공유 자원에 접근하는 코드 영역

**레이스 컨디션(Race Condition)** : 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우

ex ) 계좌 잔액과 소비자생산자 문제는 레이스 컨디션의 사례

```jsx

총합--; 코드가 있다고 가정하자
실제 실행되는 low level 언어는 다음과 같다

r2 = 총합; // 총합 변수를 레지스터에 저장
r2 = r2 - 1; // 레지스터 값 1 감소
총합= r2 // 레지스터 값을 총합 변수에 저장
```

문맥교환은 고급 언어가 아니라 저급 언어를 실행하다가 발생한다

상호 배제를 위한 동기화는 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리한다

### 상호배제를 위한 3가지 원칙

- **상호배제(mutual exclusion)** : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
- **진행(process)** : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
- **유한 대기(bounded waiting)** :  한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다(임계 구역에 들어오기 위해 무한정 대기해서는 안된다)

뮤텍스 락, 세마포, 모니터

## 뮤텍스 락 Mutex Lock

**뮤텍스 락** : 공유 자원에 하나의 프로세스가 접근 중일 때 다른 프로세스가 접근하지 못하게 막는 도구. 접근한 동안에 좌물쇠를 거는 것

ex) 비유를 하자면 탈의실에 들어간 뒤 좌물쇠를 걸어 잠군다

**뮤텍스 락 구현(단순ver)** : 하나의 전역 변수와 두 개의 함수로 구현

- 좌물쇠 역할 : 프로세스들이 공유하는 전역 변수 Lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제하는 역할 : relase 함수

**acquire 함수** :  프로세스가 임계 구역에 진입하기 전에 호출하는 함수이다. 만약 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 임계 구역을 반복적으로 확인하고, 임계 구역이 열려 있다면 임계 구역을 잠근느 함수

```jsx
acquire() {
	while (lock == true)    /* 만약 임계 구역이 잠겨 있다면 */
	     ;                  /* 임계 구역이 잠겨 있는지를 반복적으로 확인 *
	lock = true;            /* 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
}

```

**release 함수** :  임계 구역에서의 작업이 끝나고 호출하는 함수

```jsx
release() {
lock = false; /* 임계 구역 작업이 끝났으니 잠금 해제 */
}
```

acquire과  release 함수를 임계 구역 전후로 호출한다

```jsx
acquire();      // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
// 임계 구역    // 임계 구역에서의 작업 진행
releaseQ;      // 자물쇠 반환
```

**뮤텍스락의 문제점**

- **바쁜 대기(busy wait)** : while(lock==true); 와 같이 쉴 새 없이 반복하며 확인해보는 것. 권한 획득을 위해 많은 CPU를 낭비한다
- 하나의 공유 자원이 있을 경우를 가정하고 만든 도구이다
- 락을 획득한 상황 이외의 다른 맥락에서는 잠금되거나 해제될 수 없다.

### 세마포 Semaphore

**세마포** : 뮤텍스 락과 비슷하지만 여러개의 공유자원에도 활용할 수 있는 도구. 공유 자원에 개수를 고려하여 일정 수의 프로세스까지만 활용할 수 있도록 관리한다

**이진 세마포** : 사실상 뮤텍스락과 같다. 한개의 공유 자원을 관리하는 세마포

**카운팅 세마포** : 여러개의 공유자원을 관리하는 세마포

**세마포 구현(뮤텍스 처럼 구현했을 경우) S, wait(), signal()**

```jsx
S = 10;
wait(){
	while(S<=0) //만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면
		; //사용할 수 있는 자원이 있는지 반복적으로 확인하고
	S--; //임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 
				//S를 1감소시키고 임계 구역에 진입한다
}

signal(){
	S++; // 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다
}
```

세마포도 busy waiting문제가 발생한다. CPU는 더 생산성 있는 작업을 할 수 있을 텐데, while문을 돌며 CPU주기를 낭비시킨다

**세마포 구현(busy waiting문제를 해결한 경우)**

```jsx
wait(){
	S--;
	if(S<0){
		add this process to Queue; //해당 프로세스 PCB를 대기 큐에 삽입한다
		sleep(); //대기 상태로 접어든다
	}
}

signal(){
	S++;
	if(S<=0){
		remove a process p from Queue; //대기 큐에 있는 프로세스 p를 제거한다
		wakeup(p); //프로세스 p를 대기 상태에서 준비 상태로 만든다
	}
}
```

## 모니터

매번 임계 구역 앞뒤로 wait와 signal을 명시하는 것은 불편하다

휴먼 에러 발생 가능성이 너무 높다

이를 고급 언어 수준에서 활용할 수 있게 만든 것이 모니터


Monitor 기법Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다. 예를 들어 자바에서 모든 객체는 Object 클래스를 상속 받는다. 이 Object 클래스에는 wait(), notifyAll(), notify() 메소드를 가지고 있는데 이게 바로 Condition Variables 역할이라고 보면 된다. 고로 모든 자바 객체는 Monitor를 가지고 있다. 자바에서는 Mutual Exclusion 해결을 위한 구현체로 Synchronized 키워드가 있다. 예를 들어 Synchronized가 메소드에 선언되어있고, 쓰레드A가 이미 Lock을 획득해서 Critical Section(메소드)을 수행중이라고 가정하자. 쓰레드B가 동일한 메소드를 수행하기 위해 해당 Object의Lock을 획득해야 할 것이다. 이 Lock이 반환될 때까지 대기를 해야하는데 그 때 사용되는게 바로 Monitor다. 쓰레드A가 Lock을 반환하면 쓰레드B는 기다렸다가 Lock을 획득하게 된다. 그리고 Critical Section인 메소드를 수행할 수 있게 된다. 물론 Synchronized 키워드를 사용했을 때 자동적으로 수행되는 내부 동작이고, 별도로 명시적인 Monitor를 구현할 수도 있다.아무튼 Monitor는 이렇게 Mutex(Lock)과 Condition Variables을 이용해서 Mutual Exclustion을 해결하고 있다. 그 외 Monitor의 다른 정의로는 공유자원에 안전하게 접근하기 위해 Mutual Exclusion가 랩핑된 Thread-Safe한 클래스, 객체, 모듈들을 의미하기도 한다.

출처: https://about-myeong.tistory.com/34 [명찌의 포스트잇:티스토리]

## 차이점
뮤텍스와 세마포어의 차이점 뮤텍스는 공유자원을 접근할 수 있는 키가 하나인 세마포어랑 같다. 키가 하냐 쓸수 있냐? 여러개 쓸수 있냐의 차이다.​

## 세마포어와 모니터의 차이​
세마포어에 비해서 모니터 쪽이 공유자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해서 간단하다. 세마포어는 직접 키해제와 공유자원 접근 처리를 해주어야한다.

